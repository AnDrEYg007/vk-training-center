# 5. Хуки и инкапсуляция логики

Кастомные хуки являются основным инструментом для переиспользования и инкапсуляции логики в приложении. Они позволяют извлекать логику компонентов в отдельные функции, делая сами компоненты более чистыми и сфокусированными на отображении.

## 1. Назначение кастомных хуков

-   **Инкапсуляция**: Скрытие сложной логики за простым интерфейсом.
-   **Переиспользование**: Возможность использовать одну и ту же логику в разных компонентах.
-   **Разделение ответственности**: Отделение логики управления состоянием от логики рендеринга.
-   **Читаемость**: Компоненты, использующие хуки, становятся короче и понятнее.

---

## 2. Обзор ключевых хуков

### 2.1. Хуки для `ProjectsContext`

Вся логика глобального `ProjectsContext` была декомпозирована на три сфокусированных хука, которые вызываются внутри `ProjectsProvider`.

<details>
<summary><strong><code>useDataInitialization</code></strong> (`contexts/hooks/useDataInitialization.ts`)</summary>

-   **Задача**: Выполнить **только** первоначальную "жадную" загрузку всех данных при старте приложения.
-   **Как работает**: Содержит `useEffect`, который при монтировании вызывает `api.getInitialData()` и `api.getAllPostsForProjects()`, чтобы получить все проекты, посты (включая системные), заметки и счетчики. Возвращает состояние `isInitialLoading` и объект `initialData`.
</details>

<details>
<summary><strong><code>useUpdatePolling</code></strong> (`contexts/hooks/useUpdatePolling.ts`)</summary>

-   **Задача**: **Только** фоновый опрос (polling) на наличие обновлений с бэкенда.
-   **Как работает**: Запускает `setInterval`, который каждые 5 секунд вызывает `api.getUpdates()`. Если сервер возвращает список ID проектов, они добавляются в состояние `updatedProjectIds`.
</details>

<details>
<summary><strong><code>useDataRefreshers</code></strong> (`contexts/hooks/useDataRefreshers.ts`)</summary>

-   **Задача**: Содержать **все** функции для обновления, синхронизации и сохранения данных.
-   **Как работает**: Этот хук — самый большой, так как он инкапсулирует всю активную логику работы с данными:
    -   `handleRefreshPublished`, `handleRefreshScheduled`, `handleRefreshSuggested`: функции для принудительного обновления данных из VK.
    -   `handleSystemPostUpdate`: новая функция для обновления системных постов.
    -   `handleRefreshForSidebar`: комплексная функция, которая вызывается при ручном обновлении из сайдбара и координирует вызов нескольких рефрешеров.
    -   `syncDataForProject`: функция для "тихой" синхронизации данных из кеша бэкенда.
    -   `handleUpdateProjectSettings`, `handleForceRefreshProjects`: функции для сохранения настроек и полного обновления списка проектов.
</details>

### 2.2. Хуки для сложных компонентов

<details>
<summary><strong><code>useProductsManager</code></strong> (`features/products/hooks/useProductsManager.ts`)</summary>
- **Задача**: Инкапсулировать **всю** логику компонента "Товары" (`ProductsTab`).
- **Что инкапсулировано**:
    -   **Управление данными и кешированием**: Загрузка данных о товарах и подборках (`fetchData`). Использует `useLocalStorage` для кеширования данных на стороне клиента, чтобы обеспечить мгновенную загрузку при повторном открытии.
    -   **Состояние редактирования**: Отслеживает все изменения, внесенные пользователем в таблицу, в объекте `editedItems`.
    -   **Логика сохранения**: Содержит функции для сохранения как одного товара (`handleSaveItem`), так и всех изменений сразу (`handleSaveAll`), включая обработку загрузки новых изображений.
    -   **Управление режимом выбора**: Управляет состояниями `isSelectionMode`, `selectedItemIds` и всеми связанными действиями (выбор, отмена, массовое удаление).
    -   **Интеграция с AI**: Содержит логику для вызова AI-помощника для подбора категорий, как для одного товара (`handleAiSuggestCategory`), так и для группы (`handleBulkAiSuggestCategory`), и управляет состоянием модальных окон подтверждения.
- **Результат**: Компонент `ProductsTab` становится чистым "дирижером", получая всю логику из этого хука.
</details>


<details>
<summary><strong><code>useAIGenerator</code></strong> (`features/posts/hooks/useAIGenerator.ts`)</summary>
- **Задача**: Инкапсулировать **всю** логику компонента "AI-помощник" (`AIGenerator`).
- **Что инкапсулировано**:
    -   Управление системной инструкцией (выбор между дефолтной и кастомной).
    -   Управление **шаблонами (пресетами)**: загрузка, выбор активного шаблона.
    -   Логика **сохранения/обновления/создания шаблонов "на лету"**: хук содержит логику-диспетчер (`handleSavePreset`), которая определяет, нужно ли показывать модальное окно для обновления существующего шаблона или инлайн-форму для создания нового.
    -   Управление историей чата (`chatHistory`).
    -   Логика **контекстных ответов**: управление состоянием `replyToTurn`. При генерации ответа хук модифицирует промпт, добавляя в него текст цитируемого сообщения, что и позволяет AI понимать контекст.
    -   **Повторная генерация (`handleRegenerate`)**: Новая функция, которая позволяет повторно выполнить любой предыдущий запрос из истории чата, используя тот же самый пользовательский и системный промпт. Это позволяет быстро получить альтернативный вариант ответа.
    -   Управление UI-состояниями, такими как `isGenerating`, `isCreatingPreset` (для инлайн-формы), `highlightedTurnId` (для подсветки при переходе к цитате).
- **Результат**: Компонент `AIGenerator` становится "чистым", получая все необходимые данные и функции от этого хука.
</details>

<details>
<summary><strong><code>usePostDetails</code></strong> (`features/posts/hooks/usePostDetails.ts`)</summary>
- **Задача**: Инкапсулировать **всю** сложную логику модального окна `PostDetailsModal`.
- **Что инкапсулировано**:
    - Управление режимами (`view`, `edit`, `copy`).
    - Управление состоянием формы через композитный хук `usePostForm`.
    - Состояния загрузки и ошибок (`isSaving`, `saveError`).
    - Логика закрытия окна, включая **проверку на несохраненные изменения и на открытые панели AI/Переменных**.
    - **Новое:** Управление состоянием видимости панелей "AI-помощник" и "Переменные" (`showAIGenerator`, `showVariables`) и логика их загрузки.
- **Результат**: Компонент `PostDetailsModal` становится "дирижером", который получает `state` и `actions` от хука и передает их в дочерние компоненты, оставаясь чистым и декларативным.
</details>

<details>
<summary><strong><code>useProjectSettingsManager</code></strong> (`features/projects/hooks/useProjectSettingsManager.ts`)</summary>

-   **Задача**: Инкапсулировать **всю** логику модального окна настроек проекта (`ProjectSettingsModal`), делая сам компонент "глупым".
-   **Что инкапсулировано**:
    -   Управление состоянием формы (`formData`).
    -   Логика работы с вложенными редакторами переменных, тегов и **шаблонов AI**.
    -   Функции-обработчики (`handleSubmit`, `handleRefresh`).
    -   Состояния загрузки (`isSaving`, `isRefreshing`, `isAiRunning`).
</details>

<details>
<summary><strong><code>usePostForm</code> (Композитный)</strong> (`features/posts/hooks/usePostForm.ts`)</summary>

-   **Задача**: Управлять состоянием формы в `PostDetailsModal`, выступая "дирижером" для более мелких хуков.
-   **Как работает**: Этот хук использует **композицию**:
    1.  Вызывает `useBulkCreationManager` для получения состояния и логики массового/мультипроектного создания.
    2.  Вызывает `useDirtyCheck` для получения флага `isDirty`.
    3.  Управляет оставшимися простыми состояниями (текст, изображения, режим публикации).
    4.  Возвращает единый объект с `formState` и `formActions` для компонента.

-   **Дочерние хуки `usePostForm`**:
    -   **`useBulkCreationManager`**: Управляет **только** состоянием `isBulkMode`, `isMultiProjectMode`, `dateSlots` и `selectedProjectIds`, а также функциями для их изменения.
    -   **`useDirtyCheck`**: Содержит **только** сложную логику сравнения текущего состояния формы с оригинальным постом. Принимает все части состояния и возвращает один булев флаг `isDirty`.
</details>

<details>
<summary><strong><code>useScheduleManager</code> (Композитный)</strong> (`features/schedule/hooks/useScheduleManager.ts`)</summary>

-   **Задача**: Управлять всей логикой вкладки расписания (`ScheduleTab`).
-   **Как работает**: Является эталонным примером композитного хука. Он объединяет:
    -   `useScheduleData`: Логика данных (посты, заметки).
    -   `useScheduleInteraction`: Логика UI (drag-and-drop, выбор).
    -   `useScheduleModals`: Логика состояния модальных окон.
-   **Результат**: Компонент `ScheduleTab` получает всю необходимую логику через один хук, оставаясь чистым и декларативным.

- **Ключевые функции `useScheduleInteraction`**:
  - **`handleConfirmDrop(id, newDate, isCopy, type, copyDestination, closeModal)`**: Эта функция была доработана. Теперь она принимает новый необязательный параметр `copyDestination`, который может быть `'system'` (по умолчанию) или `'vk'`. На основе этого параметра она устанавливает флаг `scheduleInVk` при вызове `api.savePost`. Это позволяет гибко управлять, куда будет сохранена копия поста при операции drag-and-drop.
</details>

### 2.3. Простые хуки

<details>
<summary><strong><code>useLocalStorage</code></strong> (`shared/hooks/useLocalStorage.ts`)</summary>

-   **Задача**: Абстрагировать работу с `localStorage` браузера.
-   **Как работает**: Предоставляет интерфейс, идентичный `useState`, но автоматически сохраняет состояние в `localStorage`.
</details>

<details>
<summary><strong><code>useRecentEmojis</code></strong> (`features/emoji/hooks/useRecentEmojis.ts`)</summary>

-   **Задача**: Управлять списком недавно использованных эмодзи для проекта.
-   **Как работает**: Использует `useLocalStorage` для персистентности данных.
</details>