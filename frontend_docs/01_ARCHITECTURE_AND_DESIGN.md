# 1. Архитектура и дизайн фронтенда

Этот документ подробно описывает три столпа, на которых строится архитектура фронтенд-приложения.

## 1. Структура проекта (Feature-Sliced Design)

Проект организован по принципам "feature-sliced" архитектуры для упрощения навигации и поддержки. Это означает, что код группируется по бизнес-сущностям, а не по техническим типам.

-   `src/features/`: Изолированные бизнес-фичи. Каждая папка здесь представляет собой крупный раздел приложения.
    -   `projects`: Все, что связано с проектами (сайдбар, фильтры, настройки проекта).
    -   `schedule`: Основная фича календаря-расписания.
    -   `posts`: Компоненты и логика, связанные с постами (карточки, модальное окно редактирования).
    -   `tags`: Управление тегами.
    -   `database-management`: Страница администрирования базы данных.
    -   `auth` и `users`: Фичи, связанные с аутентификацией и управлением пользователями.
    -   `products`: Новая фича для управления товарами VK Market.

-   `src/shared/`: Переиспользуемый код, который **не зависит от бизнес-логики**.
    -   `components`: Общие UI-компоненты (`ConfirmationModal`, `LazyImage`).
    -   `hooks`: Общие хуки (`useLocalStorage`).
    -   `utils`: Вспомогательные функции (`apiClient.ts`).
    -   `types`: Глобальные TypeScript-типы (`Project`, `ScheduledPost`).

-   `src/services/`: Слой для взаимодействия с внешними API. Фактически, это "контракт" того, что может делать фронтенд.
    -   **`services/api/`**: Директория, содержащая модульные файлы для каждой группы API-запросов (например, `post.api.ts`, `project.api.ts`).
    -   **`services/api.ts`**: Этот файл теперь является **"хабом" или единой точкой входа**. Он не содержит реализации, а только импортирует и ре-экспортирует все функции из модулей в папке `services/api/`.

-   `src/contexts/`: Хранилище для React Context, используемых для глобального управления состоянием.

## 2. Управление состоянием (React Context)

Вся логика работы с данными централизована с помощью React Context для избежания "пробрасывания пропсов" (prop drilling).

-   **`ProjectsContext` (`contexts/ProjectsContext.tsx`)**: Является **единственным источником правды (`Single Source of Truth`)** для всех данных, полученных с сервера (проекты, посты, заметки, глобальные переменные и т.д.).

-   **`ProjectsProvider`**: Этот компонент-провайдер оборачивает всё приложение в `index.tsx`. Он отвечает за:
    1.  **Хранение данных**: `projects`, `allPosts`, `allScheduledPosts`, `allSystemPosts`, `allNotes`, `allGlobalVarDefs`, `allGlobalVarValues` и т.д.
    2.  **Инициализацию**: При первой загрузке он запускает "жадную" загрузку всех данных с бэкенда.
    3.  **Обновление**: Содержит функции (`handleRefresh...`, `syncDataForProject`) для обновления данных по запросу пользователя или по фоновым событиям.
    4.  **Фоновый опрос**: Запускает `setInterval` для регулярной проверки наличия обновлений с бэкенда.

-   **Хук `useProjects()`**: Любой компонент, которому нужны глобальные данные или функции для их изменения, использует этот хук. Это обеспечивает прямой доступ к состоянию без передачи пропсов через все дерево компонентов.

-   **`AuthContext` (`features/auth/contexts/AuthContext.tsx`)**: Отвечает за состояние аутентификации (текущий пользователь, статус загрузки) и предоставляет функции `login`/`logout`.

## 3. Композиция компонентов и хуков

Мы избегаем создания монолитных "божественных" компонентов. Вместо этого сложный функционал разбивается на мелкие, сфокусированные части.

### Композиция компонентов

`PostDetailsModal` — идеальный пример. Вместо одного гигантского файла, он разбит на:
-   `PostTextSection`: Управляет текстовым полем, AI-помощником и переменными.
-   `PostMediaSection`: Инкапсулирует **всю логику работы с медиа**, включая загрузку, Drag-and-Drop и интеграцию с `ImageGallery`.
-   `PostDateTimePicker`: Управляет выбором даты и времени.
-   `PostCreationOptions`: Содержит переключатели для массового и мультипроектного создания.
-   ... и так далее.

Родительский `PostDetailsModal` выступает в роли "дирижера", который управляет общим состоянием и передает его дочерним компонентам.

### Композиция хуков

Это более сложный и мощный паттерн, который является ключевым для управления сложными фичами. Композитный хук объединяет несколько более мелких, сфокусированных хуков в один, предоставляя компоненту единый, простой интерфейс.

**Пример:** `useScheduleManager` (`features/schedule/hooks/useScheduleManager.ts`) объединяет в себе три других хука:
-   `useScheduleData`: Отвечает за логику получения и обновления данных для календаря.
-   `useScheduleInteraction`: Отвечает за UI-взаимодействия (drag-and-drop, режим выбора, переключение недель).
-   `useScheduleModals`: Отвечает за состояние всех модальных окон на странице расписания.

**Результат**: Компонент `ScheduleTab` становится очень "чистым". Он просто вызывает `useScheduleManager()` и получает от него готовые `state` и `actions`, не зная о сложной внутренней реализации. Аналогичный подход используется в фиче "Товары" с хуком `useProductsManager`.

## 4. Принципы производительности

Для обеспечения отзывчивого и плавного пользовательского опыта, приложение придерживается следующих принципов:

-   **Мемоизация**: Ключевые компоненты, которые рендерятся в больших списках или сетках (например, `PostCard`), обернуты в `React.memo` для предотвращения ненужных перерисовок.

-   **Стабильность `props`**: Все функции и объекты, передаваемые в качестве `props` в мемоизированные компоненты, стабилизируются с помощью хуков `useCallback` и `useMemo`.

-   **Стабильная композиция компонентов (Stable Component Composition)**: **Категорически запрещено** определять дочерние компоненты внутри функции рендеринга родительского компонента. Это является анти-паттерном, так как на каждой перерисовке родителя создается *новый тип* дочернего компонента, что заставляет React **полностью перемонтировать** его, а не обновлять. Это приводит к потере внутреннего состояния и визуальным артефактам (например, "моргание" изображений).
    -   **Пример**: Рефакторинг `PostCard.tsx`, в ходе которого компоненты `ImageGrid`, `AttachmentsDisplay` и `PostTags` были вынесены за пределы основного компонента, является эталонной реализацией этого принципа.

-   **Ленивая загрузка (Lazy Loading)**: Изображения загружаются "лениво" с использованием компонента `LazyImage`, что ускоряет первоначальную отрисовку страницы.

-   **Предотвращение "скачков" макета (Layout Shift)**: Для изображений заранее резервируется пространство с помощью контейнеров с фиксированным соотношением сторон, чтобы избежать смещения контента после загрузки медиа.