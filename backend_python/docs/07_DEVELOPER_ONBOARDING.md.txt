# 7. Руководство для нового разработчика (Onboarding)

*Цель: Дать новому разработчику быстрый старт для работы с бэкендом, объяснив ключевые концепции и рабочий процесс.*

## 1. Ментальная модель: "Слои"

Весь бэкенд построен на четком разделении ответственности по слоям. Понимая этот поток, вы сможете легко ориентироваться в коде.

**`[Router]` ➡ `[Service]` ➡ `[CRUD / External API]`**

1.  **`routers/` (Слой API):**
    -   **Задача:** Принять HTTP-запрос.
    -   **Что делает:** Валидирует входящие данные с помощью Pydantic-схем и **немедленно вызывает** функцию из сервисного слоя.
    -   **Запрещено:** Не содержит бизнес-логики, не обращается к БД напрямую.

2.  **`services/` (Слой бизнес-логики):**
    -   **Задача:** Выполнить бизнес-задачу.
    -   **Что делает:** Координирует работу. Вызывает `crud` для получения/сохранения данных, `vk_service` для общения с VK, `gemini_service` для AI.
    -   **Пример:** Функция `refresh_posts` сначала вызовет `vk_service` для получения данных, затем `crud` для их сохранения в БД.

3.  **`crud/` (Слой доступа к данным):**
    -   **Задача:** Работать с базой данных.
    -   **Что делает:** Выполняет конкретные SQLAlchemy-запросы (`SELECT`, `INSERT`, `UPDATE`, `DELETE`).
    -   **Запрещено:** Не содержит бизнес-логики, не знает о VK или AI.

## 2. Ваш первый таск: Добавляем новый API эндпоинт

Допустим, нам нужно создать эндпоинт `POST /api/projects/archive`, который архивирует проект.

**Шаг 1: Схема данных (`schemas/`)**
-   Откройте `api_payloads.py.txt`. Нам нужен ID проекта. Такая схема уже есть: `ProjectIdPayload`. Переиспользуем её.
-   Откройте `api_responses.py.txt`. Нам нужен простой ответ об успехе. Такая схема уже есть: `GenericSuccess`. Переиспользуем.

**Шаг 2: Слой CRUD (`crud/`)**
-   Нужно обновить поле `archived` у проекта. Функция для обновления уже есть: `project_crud.update_project_settings`. Переиспользуем её.

**Шаг 3: Слой Сервисов (`services/`)**
-   Откройте `management_service.py.txt` (так как архивация — это часть управления).
-   Создайте новую функцию:
    ```python
    def archive_project(db: Session, project_id: str):
        project = crud.get_project_by_id(db, project_id)
        if not project:
            raise HTTPException(404, "Project not found")
        project.archived = True
        db.commit()
        # ... возможно, нужно что-то еще, например, обновить кеш
    ```
    *Примечание: в данном случае `update_project_settings` не совсем подходит, так как он более общий. Проще обновить поле напрямую.*

**Шаг 4: Слой Роутеров (`routers/`)**
-   Откройте `routers/management.py.txt`.
-   Добавьте новый эндпоинт:
    ```python
    @router.post("/archiveProject", response_model=schemas.GenericSuccess)
    def archive_project(payload: schemas.ProjectIdPayload, db: Session = Depends(get_db)):
        management_service.archive_project(db, payload.projectId)
        return {"success": True}
    ```

**Шаг 5: Тестирование**
-   Запустите сервер, откройте `/docs` и протестируйте новый эндпоинт.

## 3. Частые ошибки и "Грабли"

-   **Циклические зависимости (Circular Imports):**
    -   **Проблема:** `service_A` импортирует `service_B`, а `service_B` импортирует `service_A`. Python выдаст ошибку `ImportError: cannot import name ...`.
    -   **Решение:** Используйте **отложенный импорт** внутри функции, где это необходимо.
        ```python
        def my_function():
            from . import service_B # Импорт внутри функции
            service_B.do_something()
        ```

-   **Работа с сессией БД:**
    -   **Правило:** Каждая функция в роутере **обязана** получать сессию через `db: Session = Depends(get_db)`.
    -   **Проброс:** Эту сессию `db` необходимо передавать дальше по цепочке вызовов (`service` -> `crud`).
    -   **Запрещено:** Никогда не создавайте сессию вручную (`db = SessionLocal()`) внутри сервисов или CRUD. Это нарушит изоляцию транзакций.

-   **Коммиты (`db.commit()`):**
    -   **Правило:** Коммиты должны происходить на **сервисном слое** после завершения бизнес-операции.
    -   **Запрещено:** Не делайте `db.commit()` внутри `crud`-функций. CRUD-функции могут быть частью более крупной транзакции, и преждевременный коммит может нарушить ее атомарность.
