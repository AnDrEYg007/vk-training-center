
# Техническое задание: Автоматизация "Универсальные Конкурсы"

## 1. Введение
Модуль предназначен для создания гибких конкурсных механик (Giveaways), где победитель определяется случайным образом среди участников, выполнивших заданные условия.
**Ключевое отличие:** Возможность создания множества параллельных конкурсов в одном проекте и гибкий конструктор условий.

---

## 2. Дизайн и UI/UX (Frontend)

При реализации строго придерживаться **Feature-Sliced Design**.
**Путь:** `features/automations/general-contests/`

### 2.1. Список конкурсов (Dashboard)
**Компонент:** `GeneralContestsList.tsx`
**Референс:** `features/automations/ai-posts/components/AiPostList.tsx`

*   **Макет:** Grid (сетка).
*   **Карточка (`GeneralContestCard`):**
    *   **Статус:** Активен (пульсирующий зеленый), Пауза (серый), Ошибка (красный), Завершен.
    *   **Данные:** Название, Дата старта, Дата итогов, Кол-во участников (если сбор уже идет), Прогресс призов (Доступно/Всего).
    *   **Действия:** Редактировать, Удалить.

### 2.2. Редактор конкурса (Editor Page)
**Компонент:** `GeneralContestEditorPage.tsx`
**Референс:** `features/automations/reviews-contest/ReviewsContestPage.tsx`

**Структура (Split Screen):**
*   **Левая часть (Scrollable):** Вкладки настроек.
*   **Правая часть (Sticky):** Живое превью поста (`ContestPreview`) — показывает, как будет выглядеть пост старта или пост итогов (переключается).

#### Вкладки редактора:

1.  **Настройки (Settings)** — Главный экран.
    *   *Название автоматизации* (для себя).
    *   *Тумблер активности*.
    *   **Секция "Конкурсный пост":**
        *   Текст (RichEditor с переменными).
        *   Медиа (Галерея `PostMediaSection`).
        *   Дата и время публикации (Start Date).
    *   **Секция "Условия и Итоги":**
        *   **Конструктор условий (`ConditionsBuilder`)** — см. ниже.
        *   **Тайминг:** Выбор [Дата и Время] ИЛИ [Через Х дней/часов].
        *   **Победители:** Кол-во победителей (Input number). Тумблер "1 приз в 1 руки".
        *   **Цикличность:** Тумблер "Перезапускать автоматически". Инпут: "Через Х часов после итогов".
    *   **Секция "Шаблоны сообщений":**
        *   Текст поста итогов (с переменной `{winners_list}`).
        *   Сообщение в ЛС победителю.
        *   Комментарий-фуллбэк (если ЛС закрыто).

2.  **Промокоды (Promocodes)**
    *   **Переиспользование:** Компонент `features/automations/reviews-contest/components/PromocodesTab.tsx`.
    *   **Логика:** Привязка идет к `general_contest_id` вместо `review_contest_id`.
    *   **Валидация:** Отображать алерт, если `Свободных кодов < Кол-во победителей`.

3.  **Участники (Participants)**
    *   Таблица `ReadOnly`. Отображает тех, кто выполнил условия (после сбора).

4.  **Победители (Winners)**
    *   **Переиспользование:** `WinnersTab.tsx` (на основе `DeliveryLog`).

5.  **Лист отправки (Delivery)**
    *   **Переиспользование:** `SendingListTab.tsx`.

6.  **Блэклист (Blacklist)**
    *   **Переиспользование:** `BlacklistTab.tsx`.

### 2.3. Конструктор условий (`ConditionsBuilder`)

**Визуальная логика:** Группы условий, объединенные через **ИЛИ**. Внутри группы условия работают через **И**.

**Интерфейс:**
```text
[ Группа условий #1 ] [x]
   [x] Поставил лайк
   [ ] Сделал репост
   [x] Написал комментарий (Опционально: содержащий текст "Участвую")
   ---------------------
   + Добавить условие (Dropdown: Подписка, Рассылка, Спонсор)

      --- ИЛИ ---

[ + Добавить альтернативную группу условий ]
```

**Формат данных (Frontend -> Backend):**
```json
[
  {
    "type": "and_group",
    "conditions": [
      { "type": "like" },
      { "type": "comment", "text_contains": "Участвую" },
      { "type": "member_of_group", "group_id": "current" } // current или ID спонсора
    ]
  },
  {
    "type": "and_group", // Альтернативный вариант участия
    "conditions": [
       { "type": "repost" }
    ]
  }
]
```

---

## 3. Архитектура Бэкенда (Python)

**Модульность:** Весь функционал реализуется в новом пакете `services/automations/general/`. Не смешивать с `reviews/`.

### 3.1. Модели данных (`models_library/automations.py`)

1.  **Новая модель `GeneralContest`**:
    *   Хранит настройки, тексты, JSON условий (`conditions_schema`).
    *   Поля связи с текущим циклом:
        *   `current_start_post_id` (ID SystemPost старта).
        *   `current_result_post_id` (ID SystemPost итогов).
        *   `last_vk_post_id` (ID реального поста в VK, откуда собирать лайки).

2.  **Новая модель `GeneralContestEntry`**:
    *   Кеш участников текущего раунда. Очищается при рестарте.
    *   `user_vk_id`, `user_name`, `user_photo`.

3.  **Миграция существующих таблиц (Полиморфизм)**:
    *   Таблицы `promo_codes`, `review_contest_delivery_logs`, `review_contest_blacklist` **должны быть модифицированы**.
    *   Добавить колонку `general_contest_id` (String, Nullable, ForeignKey).
    *   Сделать колонку `contest_id` (ссылка на review_contest) **Nullable**.
    *   *Цель:* Использовать одни и те же таблицы для промокодов и логов для обоих типов конкурсов.

### 3.2. Логика работы (Service Layer)

#### A. Интеграция с Post Tracker (`post_tracker_service.py`)
Трекер — это оркестратор. Он должен "знать" о новых типах постов.

1.  **Тип поста `general_contest_start`**:
    *   Трекер публикует его как обычно (`wall.post`).
    *   **ВАЖНО:** После успешной публикации и получения `vk_post_id`, трекер должен вызвать хук `general_contest_service.on_start_post_published(db, system_post, vk_post_id)`.
    *   **Хук:**
        *   Сохраняет `vk_post_id` в настройки конкурса (`GeneralContest.last_vk_post_id`).
        *   Рассчитывает дату итогов (если стоит "через X часов").
        *   Обновляет дату публикации у связанного поста итогов (`current_result_post_id`).
        *   Меняет статус поста итогов с `paused` на `pending_publication`.

2.  **Тип поста `general_contest_result`**:
    *   Когда наступает время этого поста, трекер **НЕ** публикует его сразу.
    *   Он вызывает `general_contest_service.process_contest_results(db, post)`.

#### B. Сбор участников (`collector.py`)

Функция `collect_participants(db, contest_id)`:
1.  Читает настройки конкурса и ID поста в VK (`last_vk_post_id`).
2.  Читает схему условий (`conditions_schema`).
3.  Для каждой группы условий (OR):
    *   Инициализирует множество кандидатов `GroupCandidates`.
    *   Последовательно применяет фильтры (AND).
        *   *Лайки:* `likes.getList`.
        *   *Комментарии:* `wall.getComments`.
        *   *Репосты:* `wall.getReposts`.
        *   *Подписка:* `groups.isMember`.
        *   *Рассылка:* Проверка наличия `vk_id` в таблице `system_list_mailing` с флагом `can_access_closed=True`.
    *   Использует пересечение множеств (Python Sets) для фильтрации внутри группы.
4.  Объединяет множества всех групп (Union).
5.  Сохраняет результат в `GeneralContestEntry`, предварительно очистив старые записи.

#### C. Подведение итогов (`finalizer.py`)

Функция `process_contest_results(db, system_post)`:
1.  **Safety Check:** Проверяет кол-во свободных промокодов для этого конкурса.
    *   **FAIL:** Если кодов меньше, чем победителей -> Создает `Note` (красный стикер) в календаре на текущее время: "ОШИБКА: Не хватило призов для конкурса X". Пост итогов помечается как `error`. Цикл останавливается.
2.  **Сбор:** Вызывает `collect_participants`.
3.  **Blacklist:** Фильтрует участников по таблице `blacklist` (связанной с этим конкурсом).
4.  **Выбор:** Выбирает N случайных победителей.
    *   Если участников меньше чем N -> Все становятся победителями (или ошибка, если участников 0).
5.  **Выдача:** Маркирует N промокодов как выданные.
6.  **Публикация:**
    *   Генерирует текст поста итогов, заменяя `{winners_list}`.
    *   Публикует пост через `vk_service`.
7.  **Рассылка:**
    *   Отправляет ЛС победителям.
    *   Если ЛС закрыто -> пишет комментарий под постом победителя (если такая опция есть) или в лог ошибок.
    *   Пишет результаты в `delivery_logs`.
8.  **Рестарт (Loop):**
    *   Если `is_cyclic`:
        *   Вычисляет `next_start_date`.
        *   Создает новую пару SystemPosts (`start` и `result`) на будущее.

### 3.3. API Эндпоинты (`routers/automations_general.py`)

*   `POST /create` - Создание конкурса (и генерация первых SystemPosts).
*   `POST /update` - Обновление настроек.
*   `POST /delete` - Удаление (и удаление связанных SystemPosts).
*   `POST /get` - Получение настроек.
*   `POST /stats` - Получение списка участников и победителей.

---

## 4. План реализации (Roadmap)

### Этап 1: База данных (Backend)
1.  Создать модель `GeneralContest` и `GeneralContestEntry`.
2.  Создать миграцию для изменения существующих таблиц (`promo_codes`, logs, blacklist) -> добавить `general_contest_id` nullable.

### Этап 2: Бэкенд логика
1.  Реализовать CRUD для настроек конкурса.
2.  Обновить `post_tracker` для поддержки хуков и новых типов постов.
3.  Реализовать `collector.py` (самая сложная часть - проверка условий).
4.  Реализовать `finalizer.py` (проверка призов, выбор, рассылка).

### Этап 3: Фронтенд (UI)
1.  Создать типы и API сервис.
2.  Верстка списка конкурсов (`GeneralContestsList`).
3.  Верстка редактора (`GeneralContestEditorPage`).
4.  Реализация `ConditionsBuilder` (динамические формы).
5.  Подключение табов промокодов, победителей и логов (с учетом нового ID).

### Этап 4: Интеграция и Тесты
1.  Создать конкурс, выставить дату старта через 5 минут.
2.  Проверить публикацию старта.
3.  Выполнить условия (лайк, коммент) с тестовых аккаунтов.
4.  Дождаться времени итогов.
5.  Проверить выбор победителя, публикацию итогов и отправку ЛС.
6.  Проверить создание следующего цикла (рестарт).
