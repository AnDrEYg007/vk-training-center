
# 10. Безопасность и Шифрование

Этот документ описывает механизмы защиты чувствительных данных (токенов доступа) в базе данных.

## 1. Концепция шифрования

В приложении используется симметричное шифрование **Fernet (AES-128 в режиме CBC)** из библиотеки `cryptography`.

-   **Шифрование "At Rest":** Данные шифруются перед записью в базу данных и расшифровываются сразу после чтения.
-   **Прозрачность:** Для бизнес-логики шифрование прозрачно. В коде Python вы работаете с обычными строками, а магия происходит в слое моделей SQLAlchemy (`models_library/types.py`).
-   **Scope:** Шифруются следующие поля:
    -   `projects.communityToken`
    -   `projects.additional_community_tokens`
    -   `system_accounts.token`
    -   `ai_tokens.token`

---

## 2. Архитектурные детали реализации

### Тип данных `EncryptedString`
В файле `backend_python/models_library/types.py` реализован кастомный тип SQLAlchemy `TypeDecorator`.

#### Гибридный режим чтения (Backward Compatibility)
Реализация метода `process_result_value` (чтение из БД) содержит важную проверку:
1.  Если строка начинается с сигнатуры Fernet (`gAAAAA...`), она расшифровывается.
2.  **Если строка не имеет сигнатуры** (обычный текст), она возвращается **как есть**.

**Зачем это нужно:** Это обеспечивает отказоустойчивость при внедрении шифрования. Если в базе остались старые незашифрованные данные (или миграция прошла частично), приложение не упадет с ошибкой дешифровки, а продолжит работать, прозрачно читая старые данные. При следующем сохранении такой записи данные будут автоматически зашифрованы.

#### Fallback для разработки (Dev Mode)
Если переменная `ENCRYPTION_KEY` не задана в `.env`:
1.  Приложение **не падает**, а выводит предупреждение в консоль (`ENCRYPTION WARNING`).
2.  Тип `EncryptedString` начинает работать в режиме "прокси": он просто пропускает данные сквозь себя (текст -> текст).
3.  Это позволяет разворачивать проект локально для тестов без генерации ключей шифрования.

---

## 3. Генерация ключа

Для работы шифрования необходим секретный ключ `ENCRYPTION_KEY`.

### Как сгенерировать ключ:
Выполните следующую команду в терминале (необходим Python):

```bash
python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
```

Вывод будет выглядеть примерно так:
`biX-7sLq...ваша_длинная_строка...=`

### Куда прописать ключ:
1.  **Локально:** В файл `.env` добавьте строку:
    ```env
    ENCRYPTION_KEY="ваш_сгенерированный_ключ"
    ```
2.  **Продакшен (Yandex.Cloud):** Добавьте переменную окружения `ENCRYPTION_KEY` в настройки ревизии контейнера.

---

## 4. Автоматическая миграция при старте

В файл `main.py` встроен механизм автоматической миграции данных (`services/encryption_migration_service.py`).

**Как это работает:**
1.  При каждом запуске сервера (событие `startup`) скрипт проверяет целевые таблицы (`projects`, `system_accounts`, `ai_tokens`).
2.  Он ищет строки, которые **не** начинаются с префикса `gAAAAA`.
3.  Найденные "сырые" данные шифруются текущим `ENCRYPTION_KEY` и обновляются в БД прямым SQL-запросом.
4.  **Безопасность:** Это позволяет внедрить шифрование на уже работающем проекте без потери данных. Просто добавьте ключ и перезапустите контейнер.

---

## 5. Ротация ключей (Смена ключа)

### Вариант А: Автоматическая ротация (Рекомендуется для Cloud)

Этот метод позволяет сменить ключ с помощью переменных окружения, без доступа к консоли сервера.

**Пошаговая инструкция:**

1.  **Этап 1: Перешифровка**
    *   Создайте новую ревизию контейнера.
    *   Сохраните старую переменную `ENCRYPTION_KEY` (это будет старый ключ).
    *   Добавьте новую переменную `ENCRYPTION_KEY_NEW` и вставьте туда **новый** сгенерированный ключ.
    *   **Запустите ревизию.**
    *   Приложение при старте обнаружит `ENCRYPTION_KEY_NEW`.
    *   Запустится функция `rotate_keys_using_env`, которая расшифрует всю базу старым ключом и зашифрует новым.
    *   После успешной операции приложение выполнит `sys.exit(0)`, что приведет к остановке контейнера (статус `Error` или `CrashLoopBackOff`). **Это ожидаемое поведение**, сигнализирующее об успехе миграции и предотвращающее работу сервера со смешанной конфигурацией.

2.  **Этап 2: Обновление конфига**
    *   Создайте следующую ревизию.
    *   Удалите переменную `ENCRYPTION_KEY_NEW`.
    *   Обновите переменную `ENCRYPTION_KEY` на значение вашего **нового** ключа.
    *   **Запустите ревизию.**
    *   Приложение запустится в штатном режиме с новым ключом.

### Вариант Б: Ручная ротация (через скрипт)

Если у вас есть доступ к консоли и базе данных (например, локально).

1.  Сгенерируйте **НОВЫЙ** ключ.
2.  Остановите бэкенд-сервер.
3.  Запустите скрипт ротации локально:
    ```bash
    python scripts/rotate_keys.py
    ```
4.  Следуйте инструкциям скрипта (введите старый и новый ключи).
5.  Обновите переменную `ENCRYPTION_KEY` в настройках и запустите сервер.
