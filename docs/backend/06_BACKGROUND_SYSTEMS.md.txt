# 6. Фоновые системы: VK Callback и трекер обновлений

Этот документ описывает, как бэкенд обрабатывает асинхронные события от VK и как он сообщает фронтенду о необходимости обновить данные.

## 1. VK Callback API

VK Callback API позволяет ВКонтакте отправлять на наш сервер уведомления о событиях, происходящих в сообществах (например, "добавлен новый отложенный пост").

### `handle_vk_callback(db, request)` в `services/vk_callback_service.py`

Это единственная функция, которая обрабатывает все входящие колбэки.

-   **Эндпоинт**: `POST /api/callback` (определен в `main.py`).
-   **Поток работы**:
    1.  **Проверка типа события**: Функция смотрит на поле `type` в запросе.
    2.  **Confirmation (Подтверждение сервера)**:
        -   Если `type` равен `confirmation`, это значит, что VK проверяет доступность нашего сервера.
        -   Функция находит проект по `group_id`, извлекает из него `vk_confirmation_code` (который вы вводите в настройках VK и проекта) и возвращает его в теле ответа. Это обязательный шаг для подключения колбэков.
    3.  **Обработка событий с контентом**:
        -   Для событий `wall_post_new`, `postponed_new`, `postponed_delete` и т.д.
        -   Функция определяет, к какому проекту относится событие, по `group_id`.
        -   **Ключевая логика**: Вместо того чтобы пытаться обработать данные из самого колбэка (которые могут быть неполными), функция запускает **полное обновление** соответствующего типа контента. Например, при событии `postponed_new` она вызывает `refresh_scheduled_posts(...)`. Это гарантирует 100% консистентность данных.
        -   После успешного обновления данных в нашей БД, она вызывает `update_tracker.add_updated_project(project.id)`.
    4.  **Ответ VK**: Вне зависимости от результата, функция всегда возвращает `ok` в теле ответа. Это сообщает VK, что уведомление получено, и он не будет пытаться отправить его снова.

## 2. Пост-трекер (Фоновый публикатор и верификатор)

Это новый фоновый сервис (`services/post_tracker_service.py`), который запускается при старте бэкенда и работает непрерывно, выполняя две ключевые задачи для "системных публикаций".

### Задача 1: Публикация по расписанию

-   **Триггер**: Каждые ~50 секунд.
-   **Логика**:
    1.  Находит в таблице `system_posts` все посты со статусом `pending_publication`, у которых `publication_date` уже наступило.
    2.  Для каждого такого поста:
        -   Меняет его статус на `publishing`, чтобы не захватить его повторно.
        -   **Важно:** Перед публикацией выполняет подстановку глобальных переменных (`substitute_global_variables`).
        -   Вызывает сервис немедленной публикации `post_service.publish_now`.
        -   Если VK API возвращает ID опубликованного поста, этот ID сохраняется в поле `vk_post_id` системного поста.
        -   Если происходит ошибка, статус меняется на `error`.

### Задача 2: Верификация публикации

-   **Триггер**: Каждые ~50 секунд (сразу после задачи публикации).
-   **Логика**:
    1.  Находит в таблице `system_posts` все посты со статусом `publishing`.
    2.  Для каждого такого поста:
        -   **Проверка таймаута**: Если с момента публикации прошло более **5 минут**, а пост так и не найден, его статус меняется на `possible_error`, чтобы пользователь обратил на него внимание.
        -   **Проверка на стене**:
            -   **Способ 1 (Приоритетный)**: Если у поста есть сохраненный `vk_post_id`, трекер запрашивает у VK ~20 последних постов со стены и проверяет, есть ли среди них пост с таким ID.
            -   **Способ 2 (Запасной)**: Если `vk_post_id` нет, трекер сравнивает нормализованный текст и набор изображений системного поста с последними постами на стене.
        -   **Результат**:
            -   **Если пост найден (верифицирован)**: Трекер считает свою задачу выполненной и **полностью удаляет этот пост из таблицы `system_posts`**.
            -   **Если пост не найден**: Трекер ничего не делает и проверит его снова в следующем цикле.

## 3. Трекер обновлений (`services/update_tracker.py`)

Эта простая система служит мостом между асинхронными колбэками и синхронными запросами от фронтенда.

-   **Проблема**: Когда VK присылает колбэк, бэкенд не может "позвонить" фронтенду и сказать: "Эй, обнови данные!". Фронтенд сам должен спросить.
-   **Решение**: Трекер обновлений.

### `UPDATED_PROJECT_IDS: Set[str]`
-   Это глобальное `set` (множество), которое хранится в памяти бэкенда. Оно содержит ID всех проектов, которые были обновлены через колбэки.

### `add_updated_project(project_id)`
-   **Назначение**: Добавить ID проекта в `UPDATED_PROJECT_IDS`.
-   **Когда вызывается**: Вызывается функцией `handle_vk_callback` или `post_tracker_service` после того, как данные в БД были успешно обновлены.

### `get_and_clear_updates()`
-   **Назначение**: Вернуть список ID всех обновленных проектов и **очистить** `UPDATED_PROJECT_IDS`.
-   **Когда вызывается**: Вызывается эндпоинтом `/api/getUpdates`, который фронтенд опрашивает каждые 5 секунд.

### Общий цикл работы системы

1.  Пользователь создает отложенный пост прямо в интерфейсе VK.
2.  VK отправляет `POST` запрос (`postponed_new`) на эндпоинт `/api/callback` нашего бэкенда.
3.  `handle_vk_callback` получает запрос, вызывает `refresh_scheduled_posts` для обновления кеша в БД.
4.  После успешного обновления, `handle_vk_callback` вызывает `update_tracker.add_updated_project('id-проекта')`. `UPDATED_PROJECT_IDS` теперь содержит `{'id-проекта'}`.
5.  В течение следующих 5 секунд, фронтенд делает фоновый `POST` запрос на `/api/getUpdates`.
6.  `get_and_clear_updates()` возвращает `{"updatedProjectIds": ["id-проекта"]}` и очищает `UPDATED_PROJECT_IDS`.
7.  Фронтенд получает этот ответ и рисует синюю точку рядом с нужным проектом, сообщая пользователю о наличии обновлений.
