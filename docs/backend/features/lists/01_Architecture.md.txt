
# Архитектура модуля System Lists

**Роутер:** `backend_python/routers/lists.py`
**Сервис-фасад:** `backend_python/services/lists/system_list_service.py`

Модуль организован по принципу строгой сегрегации ответственности.

## 1. Структура пакетов

*   **`routers/lists.py`**: Принимает HTTP-запросы, валидирует схемы Pydantic, запускает фоновые задачи через `BackgroundTasks` и вызывает сервисные функции.
*   **`services/lists/`**:
    *   `list_retrieval.py`: Логика получения данных из БД (чтение).
    *   `list_sync_subscribers.py`: Логика синхронизации подписчиков (VK -> DB).
    *   `list_sync_posts.py`: Логика синхронизации постов.
    *   `list_sync_interactions.py`: Логика сбора лайков/комментов.
    *   `list_sync_history.py`: Обновление деталей профилей в истории.
    *   `list_sync_mailing.py`: Логика синхронизации диалогов (рассылки).
*   **`crud/lists/`**:
    *   Разделен на файлы по сущностям (`subscribers.py`, `posts.py`, `stats.py`, `meta.py`, `interactions.py`, `mailing.py`) для избежания гигантских файлов.
    *   `crud/lists_crud.py`: Фасад, объединяющий все функции для импорта извне.

## 2. Поток данных (Retrieval)

**Endpoint:** `/api/lists/system/getSubscribers`

1.  **Router:** Принимает фильтры (пол, статус, поиск).
2.  **Service (`list_retrieval`):** Вызывает CRUD.
3.  **CRUD (`retrieval.py`):**
    *   Функция `_apply_filters` динамически строит SQLAlchemy запрос, добавляя `WHERE` условия в зависимости от фильтров.
    *   Поддерживает поиск по ID, ссылке (`vk.com/durov`) или имени.

## 3. Task Monitor (Фоновые задачи)

Поскольку операции синхронизации длительные, используется кастомный `Task Monitor` с персистентностью в БД.

*   **Хранилище:** Таблица `system_tasks` в базе данных (через `services/task_monitor.py`).
*   **Жизненный цикл:**
    1.  Роутер создает `uuid` задачи и регистрирует её в мониторе со статусом `pending`.
    2.  Задача запускается в `BackgroundTasks` FastAPI.
    3.  Внутри задачи сервис периодически вызывает `task_monitor.update_task(taskId, status, loaded, total)`.
    4.  Фронтенд опрашивает статус через `/api/lists/system/getTaskStatus/{taskId}`.
    5.  Бэкенд хранит историю задач, периодически очищая старые записи (старше 24 часов).

### Восстановление контекста (Resume Capability)
Бэкенд предоставляет эндпоинт **`POST /api/lists/system/getActiveTasks`**.
*   Принимает `projectId`.
*   Возвращает словарь `{ "listType": "taskId" }` для всех задач этого проекта, которые находятся в статусе `pending`, `fetching` или `processing`.
*   Это позволяет фронтенду "подхватить" прогресс-бар задачи, если пользователь обновил страницу или открыл проект в новой вкладке.

## 4. Паттерн "Split Session" (Разделение сессий)

Критически важный архитектурный паттерн, внедренный в сервисы синхронизации (`list_sync_*.py`) для предотвращения ошибок базы данных при длительных операциях.

*   **Проблема:** Если открыть сессию SQLAlchemy в начале задачи и держать её открытой во время долгих сетевых запросов к VK API (Phase 2), база данных (особенно PostgreSQL в облаке) может разорвать соединение по таймауту (SSL SYSCALL error, unexpected EOF).
*   **Решение:**
    1.  **Phase 1 (Read):** Открывается короткая сессия для чтения настроек проекта и токенов. Сессия закрывается сразу после получения данных.
    2.  **Phase 2 (Network):** Выполняются запросы к VK API (например, скачивание 100к подписчиков). **Сессия с БД в этот момент закрыта.** Данные накапливаются в памяти или обрабатываются порциями.
    3.  **Phase 3 (Write):** Данные сохраняются в базу. Для сохранения каждого чанка (например, по 1000-3000 записей) открывается **новая** короткая сессия, выполняется `bulk_insert` или `bulk_update`, делается `commit`, и сессия тут же закрывается.

Этот подход гарантирует, что соединения с БД живут только доли секунды, когда они реально нужны, исключая таймауты и блокировки.
