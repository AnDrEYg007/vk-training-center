
# Логика Синхронизации (Sync Logic)

Здесь описаны алгоритмы, используемые для синхронизации данных с VK.

## 1. Синхронизация Подписчиков (`list_sync_subscribers.py`)

**Цель:** Получить актуальный список участников и обновить историю входов/выходов с гарантированной надежностью.

### Процесс загрузки (Phased Fetching)
1.  **Phase 2.1: Parallel Fetch (Основная):**
    *   Итеративно вызывает `groups.getMembers` (по 1000 шт), скачивая **всех** текущих участников группы.
    *   Используется стратегия **Smart Fallback**: Внутри каждого воркера, если текущий токен не работает, скрипт пробует следующий из пула.
    *   Если чанк (пакет данных) не удалось загрузить ни одним токеном, он не отбрасывается, а сохраняется в список `failed_chunks`.
2.  **Phase 2.2: Sequential Retry (Докачка):**
    *   После завершения параллельной фазы, скрипт проверяет наличие `failed_chunks`.
    *   Запускается **последовательная** (однопоточная) обработка этих чанков с увеличенной паузой между запросами. Это позволяет "дожать" данные при нестабильной сети или временных проблемах VK API, предотвращая пробелы в данных.

### Обработка данных
*   **Сравнение (Diff):** `New IDs` = Скачанные - В БД. `Left IDs` = В БД - Скачанные.
*   **Порог безопасности (Threshold):** Если скачано менее 95% от ожидаемого количества (предварительная разведка), процесс прерывается с ошибкой, чтобы избежать ложного удаления тысяч пользователей.

## 2. Синхронизация Постов (`list_sync_posts.py`)

**Цель:** Быстрая загрузка истории постов.

1.  **Стратегия:** "Parallel Execute with Retry Queue".
2.  **Процесс:**
    *   Общее количество постов разбивается на чанки по 200 штук (используя `execute` для пакетирования).
    *   Запросы выполняются параллельно (`ThreadPoolExecutor`).
    *   **Retry Logic:** Аналогично подписчикам, неудачные чанки (пустой ответ или ошибка сети) попадают в очередь ретраев и обрабатываются последовательно в конце задачи.
    *   **Сбор авторов:** В процессе скачивания сервис автоматически собирает ID уникальных авторов (из полей `signer_id`, `created_by` или `post_author_data`). Это используется для наполнения списка "Авторы".

## 3. Сбор Взаимодействий (`list_sync_interactions.py`)

**Цель:** Собрать лайки/комменты/репосты. Используется **Two-Phase Sync**:
1.  **Fast Scan:** `execute` запрос собирает первые 1000 лайков/репостов (или 100 комментариев) сразу для группы из 5 постов.
2.  **Deep Scan:** Для популярных постов, где активностей больше лимита Fast Scan, пост помещается в очередь `deep_scan_queue` и обрабатывается отдельными воркерами с глубокой пагинацией.
3.  **Token Filtering (Репосты):** Для сбора репостов (`wall.getReposts`) VK требует права администратора. Сервис предварительно проверяет все доступные токены через `groups.getById` и использует только те, у которых `admin_level >= 3`.

## 4. Синхронизация Рассылки (`list_sync_mailing.py`)

**Цель:** Собрать список пользователей, у которых есть диалог с сообществом.

1.  **Community Token:** Используются только токены сообщества (основной + дополнительные).
2.  **Smart Upsert:** Если пользователь уже есть в базе (например, в подписчиках), обновляются только его профильные данные и статус диалога.
3.  **Intermediate Write:** Данные сохраняются в БД пакетами по мере поступления, чтобы не потерять прогресс при сбое.

## 5. Анализ Рассылки (`list_sync_mailing_analysis.py`)

**Цель:** Определить дату начала диалога (`first_message_date`) и инициатора (`first_message_from_id`).

1.  **Алгоритм (Staggered Parallel Execute):**
    *   Использует `messages.getHistory` с `rev=1` (первое сообщение).
    *   Запросы выполняются через `execute` (по 20 пользователей за раз).
    *   **Staggering:** Внедрена искусственная задержка (`0.35s`) между запуском потоков для предотвращения ошибки VK `Code 6: Too many requests per second`.
2.  **Обработка сбоев:** Неудачные пакеты переходят в фазу последовательного ретрая.

## 6. Синхронизация Авторов (`list_sync_authors.py`)

**Цель:** Сформировать список людей, которые публиковали посты в группе.

1.  **Сбор ID:** Происходит автоматически ("на лету") во время синхронизации постов (`list_sync_posts.py`).
2.  **Обогащение (Details Task):** Запускается отдельная задача `refresh_author_details_task`. Она берет собранные ID и массово обновляет их профили (ФИО, фото) через `users.get`.
3.  **Сохранение:** Данные сохраняются в таблицу `system_list_authors`.

## 7. Обновление деталей профилей

Фоновые задачи (`refresh_subscriber_details_task`, `refresh_interaction_users_task`) для обновления информации о пользователях (статус, город, фото), которые **уже есть** в базе. Используют `users.get`, Split Session и Smart Fallback ротацию токенов.
