# Техническое задание и Логика работы "Универсального конкурса" (General Contest)

Этот документ служит полным описанием структуры, логики и правил работы функционала "Универсальный конкурс". Документ будет дополняться по мере поступления информации от заказчика.

## 1. Общее описание
"Универсальный конкурс" (General Contest) — это самостоятельная сущность внутри проекта. В рамках проекта может быть создано и запущено множество независимых экземпляров таких конкурсов.

Основная цель сущности — автоматизировать проведение розыгрышей призов среди аудитории с четким жизненным циклом от анонса до выдачи призов.

## 2. Жизненный цикл конкурса (User & Public Flow)
С точки зрения пользователя и публичной активности (ВКонтакте), полный цикл выглядит следующим образом:

1.  **Публикация анонса (Start)**
    *   Публикуется пост с описанием призов (что дарим, количество).
    *   Указываются условия участия (что нужно сделать пользователю).
    *   Указывается точная дата и время подведения итогов.

2.  **Активная фаза**
    *   Пост доступен аудитории.
    *   Пользователи выполняют условия участия.

3.  **Подведение итогов (Deadline)**
    *   Наступает указанная в анонсе дата и время.
    *    Система обязана подвести итоги в соответствии с заданными правилами.

4.  **Публикация итогов (Results)**
    *   Публикуется **отдельный пост** с итогами.
    *   В посте упоминаются победители.
    *   Объявляется, что конкурс завершен.

5.  **Выдача призов**
    *   Победителям выдаются промокоды (механизм выдачи может варьироваться, но факт выдачи обязателен).

6.  **Завершение**
    *   После публикации анонса, подведения итогов и выдачи призов механика данного экземпляра конкурса считается полностью завершенной.

## 3. Структура данных (Сущность Конкурса)

### 3.1. Служебные поля (для пользователя системы)
Эти поля нужны только для внутреннего интерфейса пользователя, чтобы различать конкурсы между собой в списке. Они **не публикуются** во ВКонтакте.

*   **Название (Internal Name)**: Краткое наименование конкурса.
    *   *Пример*: "Новогодний розыгрыш", "Розыгрыш айфона".
    *   *Назначение*: Идентификация в списке конкурсов.
*   **Описание (Internal Description)**: Заметка или расширенное описание для самого себя.
    *   *Пример*: "Розыгрыш для привлечения новой аудитории из Москвы".
    *   *Назначение*: Напоминание о сути конкурса, чтобы не запутаться.

### 3.2. Публичные поля и настройки (Выбор источника и Стандартный сценарий)
В настройках конкурса пользователь выбирает способ старта через переключатель (тумблер):

#### Сценарий А: "Создать Новый Пост" (Стандартный / По умолчанию)
В этом режиме пользователь полностью формирует будущий пост внутри интерфейса конкурса.

1.  **Дата и время публикации**:
    *   Поле выбора даты и времени (локальное время).
    *   Определяет момент, когда пост попадет в ленту сообщества и конкурс начнется.
2.  **Текст поста**:
    *   Поле ввода основного контента.
    *   **Поддержка переменных**: Обязательная поддержка вставки локальных и глобальных переменных (например, `{WinnerCount}`, `{ProjectName}`).
    *   **UI**: Интерфейс должен иметь меню/кнопку для выбора и вставки переменных (как в "Отложенных записях").
3.  **Медиа-вложения**:
    *   Возможность загрузить и прикрепить изображения (Drag & Drop или выбор из устройств).
4.  **Результат**:
    *   Система создает запись в БД с типом `GENERAL_CONTEST_START`.
    *   Пост отображается в расписании.
    *   Автоматическая публикация произойдет в указанное время через планировщик.

#### Сценарий Б: "Выбрать Существующий Пост"
Позволяет привязать механику к уже опубликованному посту (созданному вручную или вне системы).

1.  **Способ 1: Вставка ссылки**:
    *   Поле ввода URL.
    *   Парсинг ID поста из ссылки.
    *   Подтягивание превью (текст, картинка) для верификации.
2.  **Способ 2: Выбор из базы**:
    *   Кнопка "Выбрать из списка".
    *   Модальное окно со списком опубликованных постов.
    *   Функция "Обновить список" (запрос последних 50-100 постов из API ВК) для поиска свежих публикаций.

*При выборе существующего поста статус конкурса может быть сразу переведен в "Запущен" (если пост валиден), а этап планирования пропускается.*

### 3.3. Условия и Призы (Логика выбора победителей)
Система поддерживает гибкую настройку условий участия.

#### 1. Источники участников (Entry Actions)
Определяют, какое действие должен совершить пользователь, чтобы попасть в список претендентов.
*   **Лайк (Like)**:
    *   Система опрашивает API ВК (методом `likes.getList`) и получает список ID пользователей, поставивших лайк на пост конкурса.
*   **Репост (Share)**:
    *   Система получает список ID пользователей, сделавших репост записи (методом `wall.getReposts`).
*   **Комментарий (Comment)**:
    *   Система скачивает комментарии к посту (методом `wall.getComments`).
    *   Формируется список уникальных участников (авторов).

#### 2. Обязательные фильтры (Requirements)
Применяются для отсева не соответствующих условиям участников из исходного списка (логика **И**).
*   **Подписка на текущее сообщество**:
    *   Проверка подписки через `groups.isMember`.
    *   Оставляем только тех, кто состоит в группе.
*   **Подписка на спонсора (Другое сообщество)**:
    *   Пользователь указывает ID или ссылку на группу спонсора.
    *   **Валидация**: При настройке система делает пробный запрос. Если список участников группы-спонсора скрыт (приватность), система выдает ошибку и запрещает добавлять такого спонсора (так как проверить подписку технически невозможно без токена админа той группы).
    *   При подведении итогов: проверяем наличие подписки через `groups.isMember` с указанием `group_id` спонсора.
*   **Подписка на рассылку (Разрешены сообщения от сообщества)**:
    *   Проверка того, может ли сообщество отправить личное сообщение данному пользователю (есть активный диалог / нажата кнопка "Разрешить сообщения").
    *   **Метод проверки**: Используется независимый метод (например, `messages.isMessagesFromGroupAllowed` или проверка флага `can_write_private_message` в рамках контекста сообщества) непосредственно в момент подведения итогов для каждого кандидата.
    *   **Цель**: Гарантировать, что победитель сможет получить свой приз (промокод) в личные сообщения.

#### 3. Алгоритм выбора победителей (Логика "И" - Пересечение)
Система работает по принципу жесткого пересечения множеств (INTERSECTION), чтобы найти только тех пользователей, которые выполнили **абсолютно все** заданные условия.

1.  **Этап 1: Сбор первичных списков (Action Lists)**
    *   Если выбрано условие "Лайк": Получаем список ID пользователей `L []`.
    *   Если выбрано условие "Репост": Получаем список ID пользователей `R []`.
    *   Если выбрано условие "Комментарий": Получаем список ID пользователей `C []`.
    *   *Если какое-то действие не выбрано, оно помечается как `null` и не участвует в фильтрации.*

2.  **Этап 2: Поиск пересечений (Core Verification)**
    *   Находим общих пользователей, присутствующих **во всех** активных списках.
    *   *Пример*: Если выбраны Лайк и Репост, то `Candidates = L ∩ R`. (Пользователь должен быть и в списке лайкнувших, и в списке репостнувших).
    *   Результат: Список кандидатов `Set_1`, выполнивших все активные действия.

3.  **Этап 3: Проверка статусов (Status Verification)**
    *   Для каждого пользователя из списка `Set_1` выполняем проверки "на лету" (или пакетно):
        *   **Подписка на группу**: Если условие активно -> проверяем. Если нет -> исключаем из `Set_1`.
        *   **Подписка на спонсора**: Если условие активно -> проверяем. Если нет -> исключаем.
        *   **Подписка на рассылку**: Если условие активно -> проверяем. Если нет -> исключаем.
    *   Результат: Финальный список `Final_Candidates`, прошедший сквозь все фильтры.

4.  **Этап 4: Рандомизация и Выбор**
    *   Из списка `Final_Candidates` случайным образом выбираются `N` победителей.
    *   **Правило "Недостаточно участников"**: Если размер `Final_Candidates` < количества призов (`N`), то победителями становятся все участники из `Final_Candidates`, а оставшиеся призы остаются неразыгранными (или администратор получает уведомление).

5.  **Форматирование**:
    *   Список победителей преобразуется в кликабельные упоминания: `@id12345 (Имя Фамилия)`.
    *   Этот список передается в переменную `{winners_list}` для использования в Посте-Итогов.

#### 4. Сложная логика условий (Группы условий: (A и B) ИЛИ (C и D))
Система должна поддерживать создание альтернативных путей участия (логика **ИЛИ** между группами условий).

*   **Концепция**: Пользователь может выполнить условия Группы 1 **ИЛИ** условия Группы 2, чтобы попасть в финал.
*   **Пример**: (Быть подписчиком нашей группы **И** Поставить лайк) **ИЛИ** (Написать комментарий **И** Быть подписчиком партнера).
### 3.3.1. Детальная настройка условий
*   **Длительность (Timing)**:
    *   Можно задать точную дату финиша.
    *   Либо задать **Длительность** (через X дней/часов). Это критически важно для цикличных конкурсов (чтобы каждый следующий цикл длился, например, ровно 3 дня).
*   **Комментарии (Ключевые слова)**:
    *   Поле настройки: "Текст содержит" (Text Contains).
    *   Если пусто: Засчитывается любой комментарий.
    *   Если заполнено (например, "Участвую"): Фильтруем комментарии по вхождению подстроки (регистронезависимо).
*   **Один приз в одни руки (Unique Winner)**:
    *   Тумблер (Boolean).
    *   **Вкл (Default)**: Один `user_id` может получить только один приз, даже если количество участников меньше числа призов.
    *   **Выкл**: Если участников мало, один человек может занять несколько призовых мест и получить несколько промокодов (каждое место рассчитывается независимо).

### 3.3.2. Черный список (Blacklist)
Инструмент для исключения нежелательных пользователей из всех конкурсов проекта.
*   **Логика**: Работает аналогично модулю "Конкурс Отзывов".
*   **Применение**: На этапе фильтрации кандидатов, система сверяет ID с таблицей `GeneralContestBlacklist`. Если найдено совпадение — пользователь исключается молча.
*   **Управление**: В интерфейсе настроек должна быть вкладка/модалка для добавления ID пользователей в бан.
**Алгоритм обработки групп:**
1.  **Обработка Группы 1**:
    *   Собираем списки по правилам группы 1 (например `LikeList`, `GroupMember`).
    *   Находим пересечение (INTERSECTION): `Candidates_1 = LikeList ∩ GroupMember`.
    *   Результат: Люди, выполнившие набор условий №1.

2.  **Обработка Группы 2**:
    *   Собираем списки по правилам группы 2 (например `CommentList`, `SponsorMember`).
    *   Находим пересечение (INTERSECTION): `Candidates_2 = CommentList ∩ SponsorMember`.
    *   Результат: Люди, выполнившие набор условий №2.

3.  **Объединение (UNION)**:
    *   Соединяем списки: `Final_Pool = Candidates_1 ∪ Candidates_2`.
    *   **Удаление дубликатов**: Если пользователь выполнил условия *обеих* групп, он должен присутствовать в финальном списке **только один раз**. Шансы на победу не удваиваются (1 пользователь = 1 билет).

4.  **Финальный выбор**:
    *   Из `Final_Pool` выбираются победители по стандартному алгоритму Random.

### 3.4. Настройки Поста-Итогов (Results Post / End)
Это "финишная лента" конкурса. Технически это такая же сущность, как пост-старт (дата, текст, картинки), но с особыми свойствами.

1.  **Поля настройки**:
    *   **Дата и время**: Когда конкурс должен завершиться и объявить победителей.
    *   **Текст поста**: Шаблон финального сообщения.
    *   **Медиа-вложения**: Картинки поста итогов.
2.  **Специальные переменные**:
    *   В отличие от старта, здесь обязательна поддержка динамических переменных результатов:
        *   `{Winners}` / `{UserIDs}` — упоминания победителей (ссылки на аккаунты).
        *   `{PromoCodes}` / `{PrizeInfo}` — информация о выданных призах/кодах.
        *   Внутренние переменные описания.
3.  **Отображение в системе**:
    *   При сохранении появляется в Расписании.
    *   Имеет тип `GENERAL_CONTEST_END`.
    *   Визуально отличается: "Пост подведения итогов [Название конкурса]".
    *   Позволяет пользователю видеть в календаре, когда именно произойдет розыгрыш.

### 3.5. Выдача призов и Завершение механики (Fulfillment)
После публикации поста с итогами, статус механики меняется на **"Есть итоги" (Results Published)**. Автоматизация на этом **не** заканчивается.

#### 1. Отображение данных в интерфейсе (Dashboard)
В админке конкурса пользователь должен видеть полный отчет:
1.  **Пост старта**: Ссылка, статистика (лайки/репосты/комменты).
2.  **Список всех участников**: Таблица всех пользователей, попавших в первичную выборку, с пометками, кто какие условия выполнил (✓ Лайк, ✗ Подписка).
3.  **Список победителей**: Финальный список выигравших.
4.  **Связка "Победитель - Приз"**: Каждому победителю присваивается уникальный промокод из базы.
    *   В таблице промокодов этот код помечается как `Занят` с указанием ID пользователя.

#### 2. Рассылка призов (Delivery Logic)
Система должна доставить выигрыш (промокод) пользователю.
*   **Канал**: Личные сообщения (через API ВК, токен сообщества).
*   **Шаблон**: Используется заранее настроенный шаблон сообщения ("Поздравляем! Твой промокод: {code}").
*   **Процесс**: Система пытается отправить сообщение всем победителям.

#### 3. Обработка ошибок доставки (Fallback Handler)
Если сообщение не доставлено (ошибка API: "Пользователь запретил сообщения" / "Нет диалога"):
1.  **Статус**: В интерфейсе напротив победителя ставится статус "Ошибка отправки".
2.  **Публичный пинг**: Система автоматически пишет **комментарий** от имени сообщества под стартовым постом конкурса:
    *   *Текст*: "@id123 (Имя), мы не смогли отправить приз в ЛС. Напишите нам в сообщения сообщества!".
    *   *Цель*: Уведомить победителя публично и заставить его написать нам первым.
3.  **Ручной повтор (Retry)**:
    *   В интерфейсе есть кнопка/дейсвие **"Дослать сообщения"**.
    *   Когда пользователь написал в ЛС, админ нажимает кнопку, и система повторно пытается отправить тот же самый закрепленный за ним промокод.

### 3.6. Настройки Автоматического Перезапуска (Auto-Restart)
Механика "Универсального конкурса" может работать циклично, автоматически запуская новые розыгрыши.

**Ограничение**: Автоматический перезапуск доступен **только** для **Сценария А** (Создание поста внутри системы с шаблоном). Если выбран Сценарий Б (существующий пост), опции перезапуска **скрыты или заблокированы**, так как у системы нет исходных данных (текста/фото шаблона) для генерации контента будущих циклов.

1.  **Режимы планирования**:
    *   **Ручной (One-time)**: Конкурс проходит один раз. Перезапуск только вручную.
    *   **Интервальный**: "Перезапустить через X дней/часов после завершения текущего цикла".
    *   **Ежедневный**: "Каждый день в HH:MM".
    *   **По дням недели**: "Каждый [Понедельник, Среда] в HH:MM".

2.  **Логика рестарта**:
    *   При наступлении условия перезапуска, система создает **новую пару постов** в расписании (Старт и Итог) на основе сохраненных шаблонов.
    *   Стартует **новый цикл** (Cycle) с чистой историей участников.

### 3.7. Управление призовым фондом (Промокоды)
Источник призов — внутренняя база промокодов, привязанная к конкретному Конкурсу.

1.  **Логика призов (Равнозначность)**:
    *   Все призы в списке считаются **равнозначными** по ценности.
    *   Отсутствует сложная градация мест (1-е место, 2-е место и т.д.).
    *   Победителям выдаются коды из списка "Свободных" в произвольном порядке.

2.  **Ввод данных**:
    *   Пользователь вручную вводит промокоды и их описание в интерфейсе настроек конкурса (Data Base промокодов).
    *   Каждая запись имеет структуру: `{ code: "WIN100", description: "Скидка 100р", status: "Free/Used", winner_id: null }`.

3.  **Проверка перед запуском (Pre-flight Check)**:
    *   Перед созданием нового цикла (особенно при авто-перезапуске), система проверяет остаток свободных кодов (`status: Free`).
    *   **Правило блокировки**: Если количество свободных кодов < количества победителей (например, нужно 10, а есть 8):
        *   Новый цикл **НЕ запускается**.
        *   Системные посты (Старт/Итог) **НЕ создаются** (во избежание случайной публикации).
        *   Пользователю отправляется уведомление/алерт о нехватке призового фонда.

## 4. Архитектура и интеграция с расписанием

### 4.1. Связь "Конкурс <-> Пост"
*   **Генерация ID**: При создании конкурса ему присваивается уникальный внутренний идентификатор (`contest_id`).
*   **Создание Системного Поста**: При сохранении настроек конкурса, система автоматически создает запись (пост) в базе данных.
*   **Жесткая привязка**:
    *   Созданный пост помечается специальным флагом/типом `GENERAL_CONTEST_START`.
    *   В метаданных поста прописывается `contest_id` конкретного конкурса.
    *   Система должна однозначно идентифицировать пост как "Стартовый пост конкурса 'Розыгрыш айфона'".

### 4.2. Ограничения редактирования (UX в расписании)
*   Пост отображается в общем расписании.
*   **Визуализация**: Карточка поста в календаре должна отличаться от обычных постов. Пользователь должен видеть, что это "Универсальный конкурс" и видеть его внутреннее название.
*   **Защита целостности**:
    *   Прямое редактирование этого поста через обычный редактор запрещено.
    *   При клике на пост в календаре открывается модальное окно: "Этот пост является частью настройки Конкурса. Для изменения перейдите в настройки конкурса".
    *   Присутствует кнопка перехода к редактированию самого конкурса.
    *   *Аналогия*: Поведение идентично системным постам "Конкурс отзывов" или "AI Публикации".

### 4.2a. Отображение в списке "Запланированные посты"
Логика выделения работает не только в календаре, но и в списочном представлении (List View).
*   **Идентификация**: Каждая карточка поста (как Старт, так и Итог) должна иметь четкую маркировку: "Универсальный конкурс: [Название автоматизации]".
*   **Дифференциация**: Поскольку может быть запущено несколько разных автоматизаций (например, "Розыгрыш Айфона" и "Розыгрыш Пиццы"), пользователь должен видеть, к какой именно автоматизации относится данный пост.
*   **Визуальный стиль**: Голубая аура/иконка/цветной бейдж для мгновенного считывания типа контента.

### 4.3. Бэкенд-логика: Публикация и Активация
Процесс публикации поста-анонса запускает механику конкурса:

1.  **Tracker Detection**: Пост-трекер (планировщик) видит пост конкурса в расписании (по типу `GENERAL_CONTEST_START`).
2.  **Публикация в ВК**: Трекер отправляет запрос в API ВКонтакте на публикацию.
3.  **Обработка ответа ВК**: ВКонтакте возвращает `post_id` (ID опубликованного поста).
4.  **Обновление статуса Конкурса**:
    *   Система находит связанный конкурс по `contest_id`.
    *   **Сохранение ID**: Записывает полученный `vk_post_id` в базу данных конкурса (это "Source Post", источник для сбора участников).
    *   **Смена статуса**: Переводит статус конкурса в **"Запущен" (Active/Running)**.
5.  **Отображение**: В настройках конкурса теперь должна отображаться ссылка на реальный пост в ВК или его ID, подтверждая, что механизм запущен по конкретному посту.

### 4.4. Статус "Опубликован" и защита целостности в Расписании
После публикации поста и получения `vk_post_id`, пост в расписании переходит в статус "Опубликован", но сохраняет жесткую связь с конкурсом.

*   **Визуализация**:
    *   В сетке расписания (среди опубликованных) пост должен иметь метку "Используется в автоматизации" или иконку конкурса.
    *   Пользователь должен сразу видеть, что это не обычный пост.
*   **Блокировка действий (Locking)**:
    *   **Редактирование и Удаление**: Прямые действия по удалению или редактированию такого поста из расписания **заблокированы**.
    *   **Причина**: Удаление поста разрушит логику работы активной механики (сбор участников, подведение итогов).
*   **Workflow отключения**:
    *   При попытке удаления/редактирования из расписания должно появляться модальное окно/сообщение: *"Этот пост обеспечивает работу активного конкурса. Для изменений сначала остановите механику в настройках конкурса"*.
    *   **Правило**: Пока статус конкурса "Запущен" (активен) — пост в расписании заблокирован. Только ручная остановка механики (выключение тумблера активности) снимает блокировку с поста.

### 4.5. Бэкенд-логика: Пост-Итогов как Триггер
Логика публикации итогов кардинально отличается от обычной публикации.

1.  **Сущность в базе**: Пост-Итогов сохраняется в базе расписания (ScheduledPost) с типом `GENERAL_CONTEST_END` и `contest_id`.
2.  **Роль в Расписании**:
    *   Это не просто контент для публикации, это **Триггер события**.
    *   Он занимает слот в календаре, показывая пользователю, когда завершится конкурс.
3.  **Обработка Трекером (Tracker Execution)**:
    *   Когда подходит время, Пост-Трекер видит тип `GENERAL_CONTEST_END`.
    *   **Важно**: Он **НЕ публикует** этот пост через стандартный метод `api.wall.post`.
    *   Вместо этого он вызывает метод сервиса конкурсов: `ContestService.process_results(contest_id)`.
    *   Tracker на этом этапе считает свою задачу выполненной.
4.  **Логика Сервиса Конкурсов**:
    1.  Запускает алгоритм выбора победителей (согласно условиям).
    2.  Берет *текст шаблона* из Поста-Итогов.
    3.  Заменяет переменные (имена победителей, промокоды) на реальные данные.
    4.  Публикует финальный сформированный контент в ВК.
5.  **Очистка (Cleanup)**:
    *   Исходный *запланированный* пост-итогов ("триггер") **удаляется из базы данных расписания** (физическое удаление записи ScheduledPost).
    *   **Причина**: Он выполнил свою функцию "спускового крючка". В календаре он больше не нужен как запланированное событие.
    *   В истории или логах конкурса (`ContestCycle`) сохраняется ссылка на **реально опубликованный** пост с итогами, чтобы администратор мог его найти.

### 4.6. Архитектура: Циклы и История (Cycles & Database Strategy)
Для поддержки перезапусков вводится разделение на "Настройки Механики" и "Конкретный Цикл".

1.  **Сущность `GeneralContest` (Родитель)**:
    *   Хранит конфигурацию: шаблоны текстов, картинки, условия отбора, правила расписания (Cron/Interval), списки промокодов.
    *   Это "инструкция" по проведению конкурса.

2.  **Сущность `ContestCycle` (Дочерняя / Запуск)**:
    *   Представляет конкретный проведенный розыгрыш (например, "Розыгрыш от 1 января", "Розыгрыш от 8 января").
    *   **Хранит данные конкретного запуска**:
        *   `start_post_vk_id`: ID поста старта в этом цикле.
        *   `end_post_vk_id`: ID поста итогов в этом цикле.
        *   `participants_snapshot`: Снимок участников (или ссылка на таблицу).
        *   `winners_log`: Кто победил, какой промокод получил, статус доставки.
        *   `status`: Created -> Active -> Finished.

3.  **Непрерывность истории**:
    *   Мы **обязаны хранить** историю всех циклов.
    *   В интерфейсе администратор должен иметь возможность "провалиться" в любой прошлый цикл и посмотреть: кто участвовал, кто победил, был ли доставлен приз.
    *   Это позволяет решать спорные ситуации ("Я выиграл месяц назад, где приз?") и анализировать эффективность (сколько участников было в прошлый раз vs сейчас).

### 4.7. Логика удаления (Safety Protocols)
Действия при попытке удалить элементы автоматизации.

1.  **Удаление поста Старта (вручную из ВК или базы)**:
    *   Если пост-источник удален, механика теряет базу для сбора участников.
    *   **Результат**: Механика останавливается. Итоги **не подводятся** (так как некого анализировать).

2.  **Удаление самой Автоматизации (Настроек)**:
    *   При попытке удалить автоматизацию, проверяется наличие **Активного запущенного цикла**.
    *   **Если есть активный цикл**, система блокирует удаление и показывает модальное окно с выбором действий:
        *   **(А) Остановить без подведения итогов**: Тумблер активности выключается. Посты остаются в ВК, но система про них "забывает". Итоги не будут подведены.
        *   **(Б) Подвести итоги сейчас (Force Finish)**:
            *   Система удаляет запланированный пост-триггер итогов из расписания.
            *   Мгновенно запускается процедура подведения итогов (выбор победителей, публикация поста итогов).
            *   После завершения автоматизация удаляется/архивируется.
        *   **(В) Отмена**: Ничего не делать.

## 5. Пользовательский интерфейс и UX

### 5.1. Интерфейс карточки конкурса (Статус: Запущен)
Когда механика перешла в статус "Запущена" (Active), интерфейс редактирования/просмотра конкурса должен изменяться:

*   **Индикатор статуса**: Явное визуальное отображение статуса "ЗАПУЩЕНА" (например, зеленый бейдж).
*   **Блок "Активный пост"**:
    *   Пользователь должен видеть, какой именно пост сейчас "в работе" у этой механики.
    *   Должна отображаться ссылка на пост ВКонтакте или превью поста.
    *   Текст: "Вот пост, который сейчас в работе у данной механики".
    *   Это дает пользователю уверенность, что система отслеживает правильную публикацию.

---
**Статус**: Ожидание ввода данных от пользователя.
