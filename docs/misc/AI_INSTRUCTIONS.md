# Инструкции для AI Ассистента

Этот файл содержит постоянные инструкции для AI-ассистента, работающего в среде Google AI Studio. Цель — сохранить контекст и правила взаимодействия между сессиями.

## 1. Общие правила общения

- **Язык:** Всегда отвечай на русском языке.
- **Комментарии в коде:** Всегда пиши комментарии в коде на русском языке.

## 2. Общий рабочий процесс

Этот раздел описывает полный цикл нашего взаимодействия от идеи до релиза.

### Шаг 1: Планирование
В ходе общения с пользователем, я фиксирую новые задачи, идеи и баги в файле `TODO.md` в разделе "К реализации".

### Шаг 2: Разработка
При написании кода или рефакторинге, я следую всем правилам, описанным в разделе "Правила работы с кодом и рефакторинг".

### Шаг 3: Тестирование и Одобрение
После завершения разработки я предоставляю детальный план тестирования согласно правилам в разделе "Процесс тестирования и верификации". Пользователь проводит тестирование.
- **Если есть замечания:** Я вношу правки и мы возвращаемся к этому шагу.
- **Если все работает корректно:** Пользователь дает явное одобрение (например, словами "одобрено", "готово", "справились", "протестировано").

### Шаг 4: Документирование
**Только после получения одобрения** я приступаю к документированию. Этот процесс включает:

1.  **Ведение журнала изменений (Новые правила по версиям)**:
    -   **Шаг 1: Поиск актуального файла.** Найди в папке `changelog/` файл с самым большим номером (например, `changelog_1.md`, `changelog_2.md` и т.д.). Если файлов нет, создай `changelog_1.md`.
    -   **Шаг 2: Проверка количества версий.** Подсчитай количество записей `## Версия X.Y.Z` в этом файле.
    -   **Шаг 3: Принятие решения:**
        -   **Если версий меньше 10:** Просто добавь новую запись о версии в конец этого файла.
        -   **Если версий 10 или больше:**
            1.  **Создай оглавление:** Внимательно проанализируй все 10+ версий в **заполненном** файле. Сгруппируй все изменения по смысловым блокам (например: Новый функционал, Улучшения UI/UX, Улучшения бэкенда и логики, Исправления багов). Напиши краткое, но емкое оглавление-саммари и **добавь его в самое начало файла**.
            2.  **Создай новый файл:** Создай **новый файл** со следующим номером (например, `changelog_2.md`) и помести запись о **текущем** изменении в него. Этот файл теперь становится актуальным для следующих 10 обновлений.

2.  **Обновление `TODO.md`**:
    - Перемещаю соответствующую задачу в секцию "Реализовано", используя формат ~~зачеркнутого текста~~.

3.  **Обновление остальной документации**:
    - Анализирую все внесенные изменения и обновляю любые затронутые файлы документации, чтобы они отражали новую реальность. Это включает, но не ограничивается:
      - `API_CONTRACT.md`
      - `DATABASE_SCHEMA.md`
      - Файлы в папке `frontend_docs/`
      - Файлы в папке `backend_python/docs/`
      - Файлы в папке `ui-kit/`
      - `README.md` и `backend_python/README.md`

## 3. Правила работы с кодом и рефакторинг

- **Принцип прямого выполнения запроса:** Строго следуй запросу пользователя. **Категорически запрещено** самостоятельно придумывать и внедрять новый функционал, фичи или проводить рефакторинг, если об этом не было явной просьбы. Твоя задача — точно выполнить поставленную задачу, а не предлагать собственные улучшения.

- **Быстрые команды для развертывания бэкенда (деплоя):** Если пользователь произносит ключевые слова, такие как "деплой", "в продакшин", "залить на сервер", "обновить прод", ты должен немедленно выполнить следующий сценарий:
  1.  **Определение версии:** Проанализируй историю общения или предоставленные логи, чтобы найти **последний** использованный тег версии (например, `v10`).
  2.  **Инкремент версии:** Увеличь номер версии на единицу (например, `v10` станет `v11`).
  3.  **Формирование команд:** Сформируй и **немедленно отправь** пользователю две готовые команды для сборки и публикации Docker-образа с новым тегом. Используй ID реестра `cr.yandex/crpq5n1men523nvih5j4/vk-planner-backend`.
  4.  **Формат ответа:** Ответ должен содержать **только эти две команды** и ничего больше, если не было явного запроса на дополнительные объяснения.

- **Быстрые команды для развертывания фронтенда:** Если пользователь произносит ключевые слова, такие как "деплой фронта", "обновить фронтенд", "залить фронт", ты должен немедленно выполнить следующий сценарий:
  1.  **Инструкция по сборке:** Напиши пользователю, что сначала нужно выполнить команду `npm run build` в корне проекта.
  2.  **Инструкция по поиску файлов:** Напиши, что после сборки нужно посмотреть в папку `dist/assets/` и скопировать новые имена для CSS и JS файлов.
  3.  **Формирование команд:** Сформируй и **немедленно отправь** три готовые команды `yc storage s3 cp` для загрузки CSS, JS и `index.html` с правильными MIME-типами. Используй плейсхолдеры `[имя-css-файла]` и `[имя-js-файла]`.
  4.  **Формат ответа:** Ответ должен содержать **только эти инструкции и три команды** и ничего больше.

- **Обязательный процесс анализа перед написанием кода:** Перед внесением любых изменений в код, будь то исправление бага, добавление новой функции или рефакторинг, ты обязан выполнить следующий процесс:
  1.  **Полный анализ документации:** Внимательно изучи всю существующую документацию:
      -   Техническую документацию по бэкенду (папка `backend_python/docs/`).
      -   Техническую документацию по фронтенду (папка `frontend_docs/`).
      -   Весь UI-кит (папка `ui-kit/`).
  2.  **Предложение вариантов решения:** На основе проанализированной информации, предложи несколько вариантов решения задачи. Опиши плюсы и минусы каждого варианта, ссылаясь на существующие архитектурные паттерны и компоненты из документации.
  3.  **Ожидание одобрения:** Начинай писать код **только после того, как пользователь явно одобрит** один из предложенных вариантов.

- **Принцип "малой крови" и переиспользования:** При реализации нового функционала необходимо действовать "малой кровью". Это означает:
  - **Переиспользование:** Всегда отдавай приоритет использованию **существующей логики, хуков, компонентов и архитектурных подходов**.
  - **Понятность важнее "сухости" (DRY):** Допускается разумное дублирование кода, если это делает новый функционал более понятным, изолированным и не требует изобретения новых, сложных абстракций.
  - **Консистентность:** Новые решения должны быть консистентны с уже написанным кодом. Новые подходы и методы изобретаются только там, где это действительно необходимо и уместно.

- **Запрет на усечение кода:** Если при редактировании файла тебе не хватает памяти или токенов, **категорически запрещено** затирать или обрезать существующие фрагменты кода. Ты должен вернуть файл целиком, даже если это потребует рефакторинга.

- **Сохранение целостности проекта:** Главный приоритет при рефакторинге — полное сохранение **функциональности, логики, структуры и внешнего вида** проекта. Все должно остаться работоспособным.

- **Процесс согласования рефакторинга:** Если ты видишь большой файл и считаешь, что его нужно отрефакторить (особенно по запросу на рефакторинг), ты должен сначала **предложить план изменений**.
  - **Предложение:** В своем ответе опиши, какие новые файлы ты создашь и какая будет их структура.
  - **Одобрение:** Начинай рефакторинг **только после моего одобрения** этого плана.
  - **Реализация:** После одобрения внедри изменения, строго следуя предложенному плану и правилам сохранения целостности проекта.

- **Стратегия рефакторинга "Хук-контейнер":** При рефакторинге большого файла (например, компонента React) с целью минимизации правок в остальной системе, необходимо следовать следующей стратегии:
  1. **Выделение логики в хук:** Вся сложная логика, управление состоянием и сайд-эффекты из компонента выносятся в отдельный кастомный хук (например, `useMyComponentLogic.ts`).
  2. **Упрощение компонента:** Исходный файл компонента (`MyComponent.tsx`) превращается в "компонент-контейнер". Он становится значительно проще: импортирует и вызывает созданный хук, получает от него все необходимые данные и функции, и передает их в JSX-разметку.
  3. **Сохранение интерфейса:** Имя компонента и его `props` остаются **без изменений**.
  - **Результат:** Такая стратегия позволяет изолировать рефакторинг внутри одного компонента и его нового хука. Другие части приложения, которые использовали этот компонент, не требуют никаких изменений, так как его "внешний контракт" (имя и `props`) не изменился.

- **Принцип модульности по умолчанию:** При внедрении любого нового функционала, как на фронтенде, так и на бэкенде, ты должен по умолчанию придерживаться принципа модульности. Не создавай "монолитный" код. Вместо этого, сразу разделяй новую логику на небольшие, сфокусированные и переиспользуемые компоненты, функции, хуки или сервисы в отдельных файлах. Это упрощает дальнейшую поддержку, тестирование и позволяет вносить изменения изолированно, не затрагивая другие части системы.

- **Формат файлов для бэкенда (Python):** Чтобы избежать конфликтов с платформой Google AI Studio, при создании или редактировании любых файлов для бэкенда на Python (в папке `backend_python`), ты должен добавлять расширение `.txt` в конце имени файла. Это правило применяется ко всем типам файлов в этой директории.
  - **Примеры:**
    - **Правильно:** `main.py`, `schemas.py`, `README.md.txt`.
    - **Неправильно:** `main.py`, `schemas.py`, `README.md`.

- **Запрет на нативный `confirm()`:** При разработке фронтенда **категорически запрещено** использовать встроенную функцию браузера `window.confirm()` или `confirm()`. Она блокирует поток выполнения, выглядит устаревшим и может быть незаметна для пользователя (особенно если окно не в фокусе).
  - **Решение:** Вместо этого всегда используй компонент `ConfirmationModal` из `shared/components/modals/ConfirmationModal.tsx`. Это потребует создания локального состояния (например, `const [showConfirm, setShowConfirm] = useState(false)`) для управления его видимостью.

- **Корректность путей импорта:** При рефакторинге или написании кода с импортами, ты **обязан указывать полные пути импорта без сокращений**, соответствующие реальной структуре проекта по файлам в репозитории. Тщательно проверяй относительные пути (например, `../../shared/types` вместо `@/shared/types`), чтобы они точно вели к целевому файлу. Избегай использования алиасов, если они явно не определены в конфигурации, и предпочитай надежные относительные пути.

## 4. Процесс тестирования и верификации

После каждого рефакторинга или внедрения нового функционала, ты обязан предоставить пользователю четкую и пошаговую инструкцию для тестирования внесенных изменений.

### После рефакторинга кода

Твоя цель — доказать, что логика, функционал и внешний вид остались без изменений. Ты должен предоставить детальный чек-лист для проверки.

- Перечисли **весь связанный функционал**, который мог быть затронут.
- Для каждого пункта функционала дай пошаговую инструкцию: **"куда зайти", "что нажать", "какой результат ожидать"**.
- Например, если ты отрефакторил модальное окно поста, инструкция должна включать проверку открытия окна в разных режимах (создание, редактирование, просмотр), сохранения, удаления, работы AI-генератора, добавления/удаления изображений, работы переключателей и т.д.

### После внедрения нового функционала

Твоя цель — помочь пользователю полностью протестировать новую возможность. Ты должен предоставить пошаговый сценарий использования новой фичи.

- Опиши, **где найти** новый функционал (в каком меню, на какой странице).
- Предоставь четкую последовательность действий: **"нажми на эту кнопку", "введи вот эти данные", "посмотри на результат"**.
- Опиши **ожидаемое поведение** на каждом шаге.
- Укажи на **граничные случаи**, если они применимы (например, "попробуй оставить поле пустым и нажать 'Сохранить' — должна появиться ошибка").

## 5. Правила работы с разделом "Центр обучения"

Этот раздел определяет полный рабочий процесс создания и обновления обучающих материалов для пользователей.

### Общая цель

Создавать исчерпывающие, наглядные и легко поддерживаемые руководства, которые помогают пользователям быстро освоить функционал приложения.

### Рабочий процесс

#### Шаг 1: Анализ и синхронизация

1.  **Проверка соответствия:** Перед созданием или редактированием обучающего материала, я обязан проанализировать **реальный функционал** приложения и сравнить его со структурой оглавления в файле `features/training/data/tocData.ts`.
2.  **Предложение изменений:** Если я обнаруживаю, что какая-то функция в приложении не описана в оглавлении, я должен **сначала предложить пользователю добавить** соответствующий пункт в `tocData.ts`, прежде чем приступать к написанию контента.

#### Шаг 2: Глубокий анализ кода для создания контента

1.  **Изучение исходного кода:** Для описания конкретного компонента, раздела или функции, я должен **внимательно изучить его исходный код** (компоненты `.tsx`, хуки `.ts`, сервисы и т.д.).
2.  **Извлечение информации:** В процессе анализа я должен выписать:
    -   Основное назначение компонента.
    -   Все его визуальные состояния (default, hover, active, disabled, error).
    -   Все интерактивные элементы (кнопки, поля ввода) и связанные с ними функции-обработчики.
    -   Все связанные компоненты, хуки и сервисы, от которых зависит его работа.
    -   Все `props`, которые он принимает, и что они означают.
3.  **Синтез:** Всю собранную техническую информацию я должен преобразовать в понятный для пользователя текстовый материал.

#### Шаг 3: Создание контента и визуальных примеров

1.  **Структура "Вопрос-Ответ":** Весь текстовый материал должен быть структурирован в формате диалога с пользователем:
    -   **"Что это такое?"**: Краткое и ясное описание функции.
    -   **"Как с этим работать?"**: Пошаговые инструкции и сценарии использования.
    -   **"Почему это так?"**: Объяснение логики и причин, стоящих за определенным поведением.
    -   **"Что можно?" / "Что нельзя?"**: Четкое описание возможностей и ограничений.

2.  **Визуальные примеры:**
    -   Для демонстрации UI я должен создавать **визуальные mock-компоненты** (как в `features/training/components/content/PostCardMocks.tsx`).
    -   Я обязан показать **все ключевые состояния** элемента (например, карточка опубликованного поста, системного, отложенного; карточка с 1, 3, 5+ изображениями).
    -   Каждый визуальный пример должен сопровождаться **подробным описанием**, объясняющим, что пользователь видит и почему элемент выглядит именно так.

3.  **Интерактивные "песочницы":**
    -   Для демонстрации сложных или неочевидных взаимодействий я должен создавать **интерактивные демо-компоненты** (как `InteractiveDemo` в `PostCardDeepDive.tsx`), где пользователь может безопасно попробовать функционал.

4.  **Документирование неочевидных механик:**
    -   Я должен уделять особое внимание и подробно описывать любые взаимодействия, которые не являются очевидными:
        -   **Drag-and-Drop:** Объяснить, что можно "взять" и перетащить, и какой будет результат.
        -   **Двойной клик:** Например, создание заметки по двойному клику на пустом месте.
        -   **Кликабельные области:** Например, клик по тексту поста для его сворачивания/разворачивания.

#### Шаг 4: Техническая реализация

Процесс добавления новой обучающей страницы в код должен следовать установленному паттерну:

1.  **Оглавление:** Добавить новую запись в массив `toc` в файле `features/training/data/tocData.ts`, определив `title` и уникальный `path`.
2.  **Компонент контента:** Создать новый `.tsx` файл в папке `features/training/components/content/`. Этот файл будет содержать как текстовое описание (с использованием `prose` классов), так и все необходимые визуальные и интерактивные mock-компоненты.
3.  **Регистрация:** Импортировать новый компонент в `features/training/components/TopicContent.tsx` и добавить его в `componentMap`, сопоставив его с `path`, созданным на первом шаге.