# Коммуникация и API контракт

Этот документ объясняет, как фронтенд и бэкенд "договариваются" о правилах общения в новой архитектуре.

## 1. API Контракт: Код как документация

Вместо ручного ведения файла `API_CONTRACT.md`, новая архитектура использует подход "код как документация".

-   **Что определяет контракт?**:
    -   **Схемы Pydantic (пакет `schemas/`)**: Эти Python-классы являются **единственным источником правды** для структуры данных. Они определяют, какие поля ожидает получить бэкенд и в каком формате он вернет ответ. Файлы в этом пакете разделены по назначению (`base_models`, `api_payloads`, `api_responses`).
    -   **Swagger UI (`/docs`)**: FastAPI автоматически использует схемы Pydantic для генерации интерактивной документации. Это заменяет статический Markdown-файл, предоставляя всегда актуальную и тестируемую спецификацию API.

**Правило**: Разработчик фронтенда должен ориентироваться на Swagger UI для понимания, как взаимодействовать с API.

## 2. Мост между мирами: `apiClient.ts`

Если Pydantic-схемы — это грамматика языка, то `shared/utils/apiClient.ts` — это универсальный переводчик. Его главная задача — скрыть всю сложность HTTP-взаимодействия от остальной части приложения.

### Роль `callApi`

Эта единственная функция является мостом. Вот что она делает:

1.  **Принимает простой запрос**: Компоненты вызывают ее с понятными параметрами: `callApi<ТипОтвета>('путь_эндпоинта', { данные })`. Путь может быть, например, `posts/savePost` или `management/getAllProjects`.
2.  **Формирует стандартный HTTP-запрос**:
    -   Берет базовый URL из `shared/config.ts` и добавляет к нему путь эндпоинта.
    -   Устанавливает метод `POST`.
    -   Устанавливает заголовок `Content-Type: 'application/json'`.
    -   Преобразует "данные" в JSON-строку и помещает ее в тело запроса.
3.  **Отправляет запрос**: Использует стандартный `fetch`.
4.  **Обрабатывает ответ**:
    -   Проверяет, что HTTP-статус ответа `ok` (200-299).
    -   Парсит JSON-тело ответа.
    -   Если произошла сетевая ошибка или ошибка сервера (5xx), **автоматически выполняет несколько повторных попыток** с увеличивающейся задержкой (exponential backoff).
    -   Если произошла ошибка клиента (4xx) или все попытки провалились, генерирует (`throw`) ошибку с понятным текстом, извлеченным из ответа сервера.

### Почему это так важно?

-   **Абстракция**: Код в компонентах остается чистым и декларативным (`await api.getProjects()`). Ему не нужно знать о `fetch`, `headers`, `body` и `JSON.stringify`.
-   **Централизация**: Вся логика сетевого взаимодействия, включая обработку ошибок и повторные попытки, находится в **одном месте**.
-   **Надежность**: Автоматические повторные попытки делают фронтенд более устойчивым к кратковременным проблемам с сетью или сервером.