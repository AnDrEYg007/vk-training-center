# Руководство по фронтенду (React)

Этот документ описывает архитектуру и ключевые концепции фронтенд-приложения на React.

## 1. Структура проекта (Feature-Sliced Design)

Проект организован по принципам "feature-sliced" архитектуры, что упрощает навигацию и поддержку.

-   `src/features/`: Изолированные бизнес-фичи. Например, все, что связано с проектами (`Sidebar`, `ProjectSettingsModal`), находится в `features/projects`. Все, что связано с расписанием и постами (`ScheduleTab`, `PostCard`), — в `features/schedule` и `features/posts`. Управление аутентификацией и пользователями находится в `features/auth` и `features/users`. Новая фича управления товарами находится в `features/products`.
-   `src/shared/`: Переиспользуемый код, который не зависит от бизнес-логики.
    -   `components`: Общие компоненты (модальные окна, заглушки).
    -   `hooks`: Общие хуки (например, `useLocalStorage`).
    -   `utils`: Вспомогательные функции (например, `apiClient.ts`).
    -   `types`: Глобальные типы данных (`Project`, `ScheduledPost`).
-   `src/services/`: Слой для взаимодействия с внешними API.
-   `src/contexts/`: Хранилище для React Context, используемых для глобального управления состоянием.

## 2. Управление состоянием (State Management с помощью React Context)

Архитектура управления состоянием использует React Context для централизации логики и устранения "пробрасывания пропсов" (prop drilling).

-   **`ProjectsContext` (`contexts/ProjectsContext.tsx`)**:
    -   **Источник правды для данных**: Является `Single Source of Truth` для всех данных, связанных с проектами и контентом (`projects`, `allPosts`, `allScheduledPosts` и т.д.).
    -   **`ProjectsProvider`**: Оборачивает приложение и инкапсулирует всю логику для получения и обновления этих данных (начальная загрузка, фоновый опрос, функции `handleRefresh...`).
    -   **Хук `useProjects()`**: Предоставляет компонентам доступ к данным о проектах и контенте.

-   **`AuthContext` (`features/auth/contexts/AuthContext.tsx`)**:
    -   **Источник правды для аутентификации**: Отвечает за состояние текущего пользователя (`user`) и статус загрузки (`isLoading`).
    -   **`AuthProvider`**: Оборачивает `ProjectsProvider`. Управляет состоянием сессии, сохраняя данные пользователя в `sessionStorage`.
    -   **Хук `useAuth()`**: Предоставляет компонентам информацию о текущем пользователе и функции `login`/`logout`.

-   **Роль `App.tsx`**: Корневой компонент `App.tsx` был значительно упрощен. Теперь его основная задача — управлять состоянием **пользовательского интерфейса** (таким как `activeProjectId` и `activeView`) и **координировать** вызовы функций из контекстов в ответ на действия пользователя.

-   **Локальное состояние**: Компоненты по-прежнему используют `useState` для управления своим внутренним UI (открытие модальных окон, поля ввода). Логика для раздела "Товары" полностью инкапсулирована в хуке `useProductsManager` и не затрагивает глобальные контексты.

## 3. Взаимодействие с API

Взаимодействие с бэкендом полностью абстрагировано от компонентов.

1.  **Компоненты (`*.tsx`)**:
    -   Вызывают простые и понятные функции из `api.ts`, например: `api.savePost(postData, projectId)`.

2.  **Слой API (`services/`)**:
    -   **`services/api/`**: Директория, содержащая модульные файлы для каждой группы API-запросов (например, `post.api.ts`, `market.api.ts`).
    -   **`services/api.ts`**: Файл-хаб, который ре-экспортирует все функции из модулей, предоставляя единую точку входа.
    -   Каждая функция соответствует одному эндпоинту и вызывает универсальный HTTP-клиент `callApi`.

3.  **HTTP-клиент (`shared/utils/apiClient.ts`)**:
    -   "Сердце" коммуникации. Единственное место, которое знает URL бэкенда и как формировать HTTP-запросы.
    -   Реализует **логику повторных попыток** для повышения надежности.

**Преимущество**: если URL бэкенда изменится, нужно будет изменить **только один файл** (`shared/config.ts`).

## 4. Композиция компонентов (Component Composition)

Мы разбиваем сложный UI и логику на небольшие, сфокусированные и переиспользуемые дочерние компоненты.

### Пример: Рефакторинг `PostDetailsModal`

`PostDetailsModal` декомпозирован на несколько дочерних компонентов:
-   `PostDateTimePicker.tsx`: Управляет датой и временем.
-   `PostTextSection.tsx`: Управляет текстовым полем, AI-помощником и переменными.
-   `PostMediaSection.tsx`: Управляет изображениями, вложениями и галереей.
-   ... и другие.

**Результат**: Такая структура делает кодовую базу значительно чище и проще для навигации, следуя принципу *Single Responsibility Principle*.