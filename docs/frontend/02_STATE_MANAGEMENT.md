# 2. Управление состоянием: Глубокое погружение

Этот документ подробно описывает два ключевых аспекта управления состоянием в приложении: глобальное состояние данных, управляемое `ProjectsContext`, и логику принятия решений об обновлении, реализованную в `App.tsx`.

## 1. Глобальное состояние данных (`ProjectsContext`)

`ProjectsContext` является ядром управления данными в приложении.

-   **Файл**: `contexts/ProjectsContext.tsx`
-   **Назначение**:
    1.  Быть **единственным источником правды** для всех данных, полученных с сервера.
    2.  Инкапсулировать **всю логику** для получения и обновления этих данных.
    3.  Предоставлять простой доступ к данным и функциям через хук `useProjects()`.

### 1.1. Реализация через композицию хуков

Вместо того чтобы содержать всю логику в одном гигантском файле, `ProjectsProvider` использует паттерн композиции хуков, делегируя каждую задачу специализированному хуку:

-   **`useDataInitialization` (`contexts/hooks/useDataInitialization.ts`)**: Отвечает **только** за первоначальную "жадную" загрузку всех данных при старте приложения.
-   **`useUpdatePolling` (`contexts/hooks/useUpdatePolling.ts`)**: Отвечает **только** за фоновый опрос (`setInterval`) эндпоинта `/api/getUpdates` для проверки наличия обновлений с бэкенда.
-   **`useDataRefreshers` (`contexts/hooks/useDataRefreshers.ts`)**: Содержит **все** функции для обновления, синхронизации и сохранения данных (`handleRefreshPublished`, `syncDataForProject`, `handleUpdateProjectSettings` и т.д.).

Сам компонент `ProjectsProvider` становится "дирижером": он вызывает эти хуки, собирает их состояния и функции в единый `value` и передает его в контекст.

#### Хук `useProjects()`

Любой компонент, которому нужны глобальные данные или функции для их изменения, использует этот хук. Это обеспечивает прямой доступ к состоянию без передачи пропсов через все дерево компонентов.

**Важный паттерн потребления:** Компоненты и хуки, потребляющие данные из контекста, должны обеспечивать свою синхронизацию с глобальным состоянием. Если хук (например, `useSuggestedPosts`) использует локальное состояние (`useState`) для хранения списка постов, он должен использовать `useEffect` для отслеживания изменений в пропсах, полученных из контекста. Это гарантирует, что при фоновом обновлении данных в `ProjectsContext` локальное состояние компонента немедленно обновится, и пользователь увидит актуальную информацию в UI. Этот паттерн является ключевым для предотвращения рассинхронизации интерфейса.

### 1.2. Состояния проектов (ошибки, пустые списки)

Контекст (через `useDataRefreshers`) управляет состояниями, специфичными для каждого проекта, такими как ошибки доступа или отсутствие контента.

-   **`projectPermissionErrors`**: Хранит сообщения об ошибках доступа. Это состояние **персистентно** (сохраняется в `localStorage`), чтобы пользователь видел уведомление даже после перезагрузки страницы.
-   **`projectEmptyScheduleNotices` / `projectEmptySuggestedNotices`**: Хранят информационные сообщения, если VK вернул пустой список отложенных или предложенных постов.
-   **Логика работы**:
    1.  **Установка флага:** Флаги устанавливаются в функциях-обработчиках (`handleRefreshScheduled` и др.), если API возвращает ошибку или пустой массив.
    2.  **Блокировка:** Наличие любого из этих флагов для проекта **блокирует все автоматические обновления** для него (см. "Умное" обновление ниже).
    3.  **Снятие флага:** Флаг снимается только после **успешного ручного обновления**, инициированного пользователем.

## 2. Логика "умного" автоматического обновления (`App.tsx`)

Хотя `ProjectsContext` хранит данные, именно корневой компонент `App.tsx` принимает решение, **когда** и **как** их обновлять в ответ на действия пользователя. Эта логика инкапсулирована в хуке `useEffect`, который срабатывает при изменении `activeProjectId` или `activeView`.

### Алгоритм принятия решений

`useEffect` в `App.tsx` работает по иерархическому принципу, проверяя условия в строгом порядке приоритета:

1.  **Приоритет 1: Блокировка (`return`)**
    -   **Условие**: Если у активного проекта `activeProjectId` есть флаг `projectPermissionErrors` или `projectEmpty...Notice` для текущей вкладки (`activeView`).
    -   **Действие**: `useEffect` немедленно прекращает работу (`return`). Никакие автоматические обновления не запускаются, чтобы избежать лишних запросов к API и повторного показа уведомлений. Пользователь должен инициировать обновление вручную.

2.  **Приоритет 2: Первоначальная загрузка ("холодный" старт)**
    -   **Условие**: Если данные для текущего проекта и вида отсутствуют в состоянии (`allPosts[activeProjectId] === undefined`).
    -   **Действие**: Запускается `handleRefreshForSidebar(projectId, view, true)`. Эта функция выполняет "жесткое" обновление данных напрямую из VK API, чтобы заполнить пустоту.

3.  **Приоритет 3: Синхронизация по флагу обновления ("теплый" старт)**
    -   **Условие**: Если у проекта есть флаг `updatedProjectIds` (синяя точка), указывающий на наличие фоновых обновлений на бэкенде.
    -   **Действие**: Запускается `syncDataForProject(projectId, view)`. Эта функция выполняет "тихую" синхронизацию данных из **базы данных бэкенда**, а не из VK. Это быстрый и эффективный способ получить уже обработанные бэкендом данные.

4.  **Приоритет 4: Проверка "устаревшего" кэша**
    -   **Условие**: Если ни одно из вышеперечисленных условий не выполнено (данные есть, но они могут быть устаревшими).
    -   **Действие**: Запускается асинхронная функция `checkStaleness`, которая:
        1.  Делает запрос к `api.getProjectUpdateStatus()`, чтобы спросить у бэкенда, какие проекты имеют устаревший кэш.
        2.  Если активный проект `activeProjectId` находится в списке "устаревших", запускается точечное обновление для нужного типа постов (`handleRefreshPublished`, `handleRefreshScheduled` и т.д.).

**Результат**: Эта сложная, но эффективная логика обеспечивает "разумное" поведение приложения. Оно не делает лишних запросов, уважает состояния ошибок, быстро подгружает недостающие данные и поддерживает кэш в актуальном состоянии, обеспечивая баланс между производительностью и свежестью данных.
