# 3. Взаимодействие с API

Взаимодействие с бэкендом является одной из ключевых задач фронтенда. В нашем приложении эта логика выстроена в виде четкой трехуровневой абстракции, чтобы сделать код чистым, надежным и легко поддерживаемым.

## Трехуровневая архитектура

**`[Компонент]` -> `[Слой сервисов]` -> `[HTTP-клиент]`**

### Уровень 1: Компоненты (папка `features/`)

-   **Роль**: Инициировать действие.
-   **Описание**: Компоненты — это "потребители" API. Когда пользователь нажимает кнопку (например, "Сохранить пост"), компонент вызывает простую, понятную функцию из слоя сервисов.
-   **Пример**: `await api.savePost(postData, projectId);`
-   **Ключевой принцип**: Компонент **не знает**, как устроен HTTP, какой URL у бэкенда, какие заголовки нужно отправлять или как обрабатывать сетевые ошибки. Он просто говорит, *что* он хочет сделать.

### Уровень 2: Слой сервисов (`services/`)

-   **Роль**: Определить "контракт" доступных действий и обеспечить модульность.
-   **Описание**: Этот слой теперь имеет модульную структуру:
    -   **`services/api/`**: Папка, содержащая отдельные файлы для каждой группы API-запросов (`post.api.ts`, `project.api.ts`, `ai.api.ts`, `market.api.ts` и т.д.). Каждый файл определяет функции, соответствующие эндпоинтам своей доменной области.
    -   **`services/api.ts`**: Этот файл теперь является **"хабом" или единой точкой входа**. Он не содержит реализации, а только импортирует и ре-экспортирует все функции из модулей в папке `services/api/`.
-   **Пример из `services/api/post.api.ts`**:
    ```typescript
    export const savePost = async (post: ScheduledPost, projectId: string): Promise<ScheduledPost> => {
        return callApi<ScheduledPost>('savePost', { post, projectId });
    };
    ```
-   **Ключевой принцип**: Компоненты продолжают импортировать все из `services/api`, но сама логика теперь четко разделена, что улучшает организацию кода. Этот слой по-прежнему **не знает**, как именно отправляется HTTP-запрос; он делегирует всю "грязную" работу HTTP-клиенту.

### Уровень 3: HTTP-клиент (`shared/utils/apiClient.ts` и `shared/config.ts`)

-   **Роль**: Выполнить HTTP-запрос и обработать результат.
-   **Описание**: Это "сердце" всей сетевой коммуникации.
-   **Динамическая конфигурация (`shared/config.ts`)**:
    -   Этот файл содержит URL-адреса для всех трех окружений: **продакшен, предпродакшен и локальный**.
    -   При загрузке приложения он проверяет `localStorage`, чтобы определить, какое окружение выбрал пользователь, и экспортирует соответствующий `API_BASE_URL`.
-   **Функция `callApi` (`shared/utils/apiClient.ts`)**:
    -   Использует `API_BASE_URL` для формирования полного URL эндпоинта.
    -   Формирует и отправляет `POST` запрос с помощью `fetch`.
    -   Реализует **логику повторных попыток** для повышения надежности при сетевых сбоях или ошибках сервера (5xx).
    -   Обрабатывает ответы и ошибки, преобразуя их в понятный для остального приложения формат.

### Централизованная интерпретация ошибок (`services/errorService.ts`)

-   **Роль**: Преобразовать технические ошибки API в понятные для пользователя сообщения и действия.
-   **Описание**: Функция `interpretApiError` в этом файле является единой точкой для анализа пойманных ошибок. Она анализирует текст ошибки и возвращает структурированный объект `ApiErrorAction`, который говорит UI, что делать (например, показать конкретное сообщение об ошибке доступа для проекта).
-   **Преимущество**: Вместо того чтобы дублировать логику `if (error.message.includes('...'))` во многих местах, все компоненты и хуки просто передают ошибку в этот сервис и получают готовое "решение".

### Преимущества этого подхода

-   **Абстракция и чистота**: Код в компонентах остается декларативным и не загроможден деталями реализации `fetch`.
-   **Централизация**: Вся логика сетевого взаимодействия (URL, заголовки, обработка ошибок, повторные попытки) находится в **одном месте**. Если потребуется изменить способ аутентификации или перейти на `axios`, нужно будет отредактировать только **один файл**.
-   **Гибкость**: Благодаря динамической конфигурации в `config.ts`, одно и то же фронтенд-приложение может работать с любым из трех бэкенд-окружений без пересборки кода.
-   **Надежность**: Автоматические повторные попытки делают фронтенд более отказоустойчивым без дополнительного кода в каждом компоненте.