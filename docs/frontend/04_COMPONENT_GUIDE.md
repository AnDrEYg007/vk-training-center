# 4. Руководство по компонентам

Этот документ объясняет, как организованы React-компоненты в проекте, и какие типы компонентов существуют.

## 1. Разделение по слоям (FSD)

Все компоненты делятся на два основных типа в зависимости от их расположения:

### `features/*` - Компоненты-фичи

-   **Назначение**: Реализация конкретной бизнес-логики. Эти компоненты "умные" и часто содержат состояние, вызывают хуки и взаимодействуют с API.
-   **Примеры**:
    -   `features/schedule/components/ScheduleTab.tsx`: Основной компонент-вкладка для отображения календаря. Он управляет всем, что происходит внутри этой вкладки.
    -   `features/projects/components/Sidebar.tsx`: Компонент, отвечающий за отображение списка проектов и фильтров.
    -   `features/posts/components/modals/PostDetailsModal.tsx`: Сложный компонент для просмотра и редактирования поста.
    -   `features/products/components/ProductsTab.tsx`: Основной компонент для вкладки управления товарами.
    -   `features/database-management/components/ArchivePage.tsx`: Компонент, который отображает список архивированных проектов с опциями восстановления или безвозвратного удаления.
-   **Правило**: Компонент-фича может использовать другие компоненты из своей же фичи или из `shared`, но **не может** напрямую импортировать компоненты из другой фичи.

### `shared/components/*` - Переиспользуемые UI-компоненты

-   **Назначение**: Предоставление универсальных, "глупых" UI-блоков, которые не привязаны к бизнес-логике.
-   **Описание**: Эти компоненты получают все свои данные и функции-обработчики через `props`. Они не содержат сложной логики и не обращаются к API напрямую. Их задача — просто отображать то, что им передали.
-   **Примеры**:
    -   `shared/components/modals/ConfirmationModal.tsx`: Универсальное модальное окно для подтверждения любого действия.
    -   `shared/components/LazyImage.tsx`: Компонент для "ленивой" загрузки изображений с отображением скелетона.
-   **Правило**: Компоненты из `shared` могут использоваться где угодно: как в `features`, так и в других `shared`-компонентах.

**Архитектурные паттерны в `shared`**:
- **React Portal (`createPortal`)**: Некоторые компоненты, которые должны отображаться поверх всего интерфейса (например, кастомные выпадающие списки или модальные окна предпросмотра), используют порталы для рендеринга в `document.body`. Это решает проблемы с `z-index` и `overflow: hidden` в родительских контейнерах.
  - **Пример**: `shared/components/modals/ImagePreviewModal.tsx`.
- **Ленивая загрузка (`Lazy Loading`)**: Компоненты для отображения медиа (например, `LazyImage.tsx`) используют Intersection Observer или `useEffect` для отложенной загрузки изображений, что ускоряет первоначальную отрисовку страницы.

## 2. Структура фичи (Feature)

Каждая папка в `features` следует схожей внутренней структуре для поддержания порядка.

**Пример: `features/schedule/`**

-   `components/`: Содержит React-компоненты, относящиеся к этой фиче.
    -   `ScheduleTab.tsx`: "Корневой" компонент фичи.
    -   `DayColumn.tsx`: Компонент для отображения одного дня в календаре.
    -   `modals/`: Подпапка для модальных окон, специфичных для этой фичи (`ConfirmMoveModal.tsx`).
-   `hooks/`: Содержит кастомные хуки, инкапсулирующие сложную логику этой фичи.
    -   `useScheduleManager.ts`: Главный композитный хук, управляющий всей логикой календаря.
-   `types.ts` (если необходимо): TypeScript-типы, специфичные только для этой фичи.

## 3. "Умные" и "Глупые" компоненты (Smart vs Dumb)

Эта концепция активно используется в проекте:

-   **"Умные" компоненты (Контейнеры)**:
    -   Часто это корневые компоненты фич (`ScheduleTab`, `SuggestedPostsTab`, `ProductsTab`).
    -   Их задача — управлять состоянием и логикой. Они вызывают хуки (`useProjects`, `useScheduleManager`, `useProductsManager`), получают данные и передают их дочерним "глупым" компонентам.
-   **"Глупые" компоненты (Презентационные)**:
    -   Это большинство компонентов в `shared/` и многие дочерние компоненты в `features/`.
    -   Их задача — отображать UI. Они не знают, откуда пришли данные, и просто рендерят то, что получили через `props`. `PostCard.tsx` — хороший пример: он получает `post` и функции `onEdit`, `onDelete` и просто их вызывает, не зная, что произойдет дальше.

Этот подход делает код более тестируемым и переиспользуемым. "Глупые" компоненты можно легко проверить в Storybook или изолированно, так как они не имеют внешних зависимостей.