


# 4. Принципы UI/UX и поведения интерфейса

Этот документ определяет строгие правила взаимодействия пользователя с интерфейсом, направленные на предотвращение ошибок, защиту данных и экономию экранного пространства.

## 1. Защита от потери данных (Data Safety)

### 1.1. Защита модальных окон
Любое модальное окно, предполагающее ввод или изменение данных (формы, редакторы, настройки), должно быть защищено от случайного закрытия.

-   **Правило**: Если пользователь внес изменения (`isDirty = true`) или открыл сложный под-интерфейс (например, AI-генератор), клик по затемненной области (overlay) или нажатие `Esc` **не должны** закрывать окно мгновенно.
-   **Поведение**: Вместо закрытия должно появляться диалоговое окно `ConfirmationModal` с вопросом: *"У вас есть несохраненные изменения. Вы уверены, что хотите закрыть окно?"*.
-   **Исключение**: Окна, предназначенные только для просмотра (Read-only), могут закрываться по клику вне области без подтверждения.

### 1.2. Безопасность необратимых операций
Действия, влекущие за собой полную утрату или перезапись данных, считаются критическими.

-   **Что считается критическим**:
    -   Удаление записи из локальной базы данных.
    -   Отправка запросов к внешним API (VK), которые **перезаписывают** или удаляют существующие данные (редактирование поста, товара, удаление фото). Внешние системы не имеют "корзины", поэтому эти действия считаются необратимыми.
-   **Правило**: Любое такое действие должно требовать явного подтверждения через `ConfirmationModal`.
-   **Содержание подтверждения**: Текст модального окна должен четко описывать последствия.
    -   *Плохо*: "Вы уверены?"
    -   *Хорошо*: "Вы собираетесь перезаписать описание товара в VK. Старое описание будет утеряно безвозвратно. Продолжить?"

### 1.3. Безопасность чувствительных данных
Данные, которые могут быть использованы для компрометации аккаунтов (токены доступа, пароли, ключи API), требуют особого обращения в интерфейсе.

-   **Правило**: Чувствительные данные (токены, пароли) **всегда** должны быть замаскированы в таблицах и списках.
-   **Поведение**:
    -   Данные отображаются в виде звездочек или маски (например, `vk1.a.****aBcD`).
    -   **Прямое редактирование (Inline-editing)** таких полей в ячейках таблицы **строго запрещено**, чтобы избежать случайного раскрытия или изменения. Поля должны быть доступны только для чтения в общем списке.
    -   Обновление таких данных должно происходить **исключительно** через специализированный процесс (например, отдельное модальное окно авторизации или смены пароля), который требует явного намерения пользователя.

---

## 2. Валидация и обратная связь

Пользователь не должен гадать, почему кнопка не работает или данные не отправляются.

### 2.1. Визуальная валидация (Visual Feedback)
-   **Принцип**: Ошибка должна быть видна сразу, в контексте элемента, а не только в тексте общего уведомления.
-   **Реализация**:
    1.  **Красная рамка**: Поле с ошибкой (незаполненное обязательное поле, неверный формат) должно получать класс `border-red-500`.
    2.  **Фокус**: При фокусе такое поле должно иметь красное кольцо (`focus:ring-red-500`).
    3.  **Очистка**: Как только пользователь начинает изменять значение в поле с ошибкой, индикация ошибки должна исчезать (оптимистичный подход).
    4.  **Глобальное сообщение**: Допускается (и рекомендуется) показывать общий `alert` или тост ("Исправьте выделенные ошибки"), но основную информацию несет подсветка полей.

---

## 3. Визуальная иерархия и состояния

### 3.1. Активные состояния полей (Focus State)
Пользователь должен всегда четко видеть, с каким элементом он взаимодействует.

-   **Стиль**: Все активные поля ввода (`input`, `textarea`, `select`) в состоянии `:focus` должны иметь голубую рамку (`ring-2 ring-indigo-500`), соответствующую нашему UI Kit.
-   **Исключение**: Для кнопок и элементов управления, чье активное состояние и так очевидно благодаря изменению цвета фона, тени или текста (например, вкладки, кнопки-переключатели, основные CTA-кнопки в модальных окнах), использование дополнительной голубой обводки фокуса **не требуется**. В таких случаях следует использовать `focus:outline-none`.
-   **Техническое требование**: При верстке родительских контейнеров необходимо предусматривать **внутренние отступы (padding)** или `margin`, чтобы внешняя рамка (`ring`) активного элемента не обрезалась краями контейнера ( `overflow: hidden`).

### 3.2. Визуальный ритм и выравнивание (Visual Rhythm)
Элементы интерфейса, расположенные в одной строке или группе, должны иметь **одинаковую высоту** и **единую базовую линию**.

-   **Проблема**: "Пляска" элементов (одно поле выше, другое ниже, кнопка больше инпута) создает визуальный шум и ощущение небрежности.
-   **Правило**: В рамках одной формы или строки таблицы все интерактивные элементы (Inputs, Selects, Buttons) должны иметь фиксированную, идентичную высоту.
-   **Стандарт**: Для плотных интерфейсов (таблиц и массовых форм) используйте фиксированную высоту **36px** (класс `h-9`). Это гарантирует, что инпуты, селекторы и кнопки будут стоять ровно.

---

## 4. Экономия пространства и Минимализм

Интерфейс должен оставаться чистым и неперегруженным, даже при большом количестве функционала.

### 4.1. Минималистичные кнопки-иконки
В плотных интерфейсах (карточки, таблицы, списки) следует избегать текстовых кнопок.

-   **Решение**: Используйте кнопки-иконки (Icon-only buttons) стандартных размеров.
-   **Обязательное условие**: Каждая такая кнопка **обязана** иметь атрибут `title` с текстовой подсказкой, которая появляется при наведении курсора.

### 4.2. Лаконичность текстовых кнопок
Текст на кнопках должен быть максимально коротким и емким.

-   **Принцип**: Контекст должен быть понятен из расположения кнопки.
-   **Примеры**:
    -   *Нет*: "Сохранить все изменения на экране" -> *Да*: "Сохранить" или "Сохранить все".
    -   *Нет*: "Создать новый товар" -> *Да*: "Создать".

### 4.3. Контекстные (Динамические) кнопки
Избегайте нагромождения кнопок для схожих действий. Используйте одну "умную" кнопку, которая меняет свою функцию и текст в зависимости от контекста или режима.

-   **Сценарий**: У формы может быть несколько состояний (создание, редактирование, массовое действие).
-   **Реализация**: Вместо трех кнопок (`Создать`, `Сохранить`, `Обновить`), отображайте одну, текст которой меняется динамически:
    -   Ничего не выбрано / Новый объект -> **"Создать"**
    -   Выбран один объект -> **"Сохранить"**
    -   Выбрано несколько объектов -> **"Обновить (5)"**

---

## 5. Консистентность и Переиспользование (Consistency & Reuse)

Мы не изобретаем велосипед для каждой новой фичи.

-   **Правило**: Если в системе уже реализован определенный визуальный паттерн или механика (например, пунктирная кнопка добавления, способ загрузки фото), **используйте его**.
-   **Запрещено**: Создавать новые стили кнопок, инпутов или модальных окон, если они отличаются от существующих без веской причины (например, массивная кнопка "Добавить" вместо стандартной пунктирной).
-   **Цель**: Пользователь должен обучаться интерфейсу один раз. Если он знает, как добавить переменную в одном окне, он должен уметь сделать это и в другом.

### 5.1. Нативная vs Кастомная навигация (Пикеры)

-   **Принцип**: Для выбора даты и времени мы используем **кастомные компоненты** (`CustomDatePicker`, `CustomTimePicker`), а не нативные браузерные инпуты (`<input type="date">`).
-   **Причина**:
    1.  **Консистентность**: Нативные пикеры выглядят по-разному в разных браузерах (Chrome, Safari, Firefox) и операционных системах. Кастомные компоненты гарантируют единый стиль везде.
    2.  **Управление**: Кастомные пикеры позволяют нам точно контролировать логику (например, отключать прошедшие даты, задавать шаг выбора минут).
    3.  **Стиль**: Мы можем стилизовать выпадающие окна так, чтобы они соответствовали общему UI Kit приложения (скругления, тени, шрифты).
-   **Правило реализации**: Все выпадающие элементы кастомных пикеров должны рендериться через **React Portal** (`createPortal`), чтобы избежать проблем с обрезкой (`overflow: hidden`) внутри модальных окон или карточек.

---

## 6. Форматирование текста и данных

### 6.1. Отображение счетчиков
Для улучшения читаемости и визуальной чистоты, мы отказываемся от использования скобок для отображения количества элементов в пользу тире.

-   **Принцип**: `[Название] - [Количество]`
-   **Правильно**: `Товары для обновления - 5`
-   **Неправильно**: `Товары для обновления (5)`
-   **Применение**: Вкладки, кнопки фильтров, заголовки разделов.

---

## 7. Паттерны фильтрации и управления

### 7.1. Принцип локальности сброса (Reset Locality)

Кнопка сброса фильтров или очистки поиска является неотъемлемой частью механизма фильтрации.

-   **Правило**: Кнопка сброса должна располагаться в **непосредственной близости** от контролов, которые она сбрасывает (сразу после последнего фильтра или поля поиска).
-   **Запрещено**: Разносить фильтры и кнопку сброса по разным углам контейнера (например, используя `margin-left: auto` или `justify-content: space-between`). Это заставляет пользователя совершать лишние движения мышью и разрывает логическую связь между действием и его отменой.
-   **Принцип**: "Там где выбираем — там и сбрасываем".
